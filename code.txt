2026-01-24 17:44:35,161 - asyncio - DEBUG - Using proactor: IocpProactor
2026-01-24 17:44:35,164 - genie_ops - INFO - Browser worker 0 started and ready (browser will be initialized on first command)
2026-01-24 17:44:35,186 - asyncio - DEBUG - Using proactor: IocpProactor
2026-01-24 17:44:35,187 - genie_ops - INFO - Browser worker 2 started and ready (browser will be initialized on first command)
2026-01-24 17:44:35,202 - asyncio - DEBUG - Using proactor: IocpProactor
2026-01-24 17:44:35,205 - genie_ops - INFO - Browser worker 1 started and ready (browser will be initialized on first command)
INFO:     127.0.0.1:54654 - "OPTIONS /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54655 - "OPTIONS /api/directories HTTP/1.1" 200 OK
INFO:     127.0.0.1:54656 - "OPTIONS /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54654 - "OPTIONS /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54655 - "OPTIONS /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54656 - "OPTIONS /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54654 - "OPTIONS /api/submissions HTTP/1.1" 200 OK
INFO:     127.0.0.1:54658 - "OPTIONS /api/submissions HTTP/1.1" 200 OK
INFO:     127.0.0.1:54659 - "OPTIONS /api/directories HTTP/1.1" 200 OK
INFO:     127.0.0.1:54657 - "OPTIONS /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54659 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54658 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54656 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54655 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54658 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54659 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54657 - "OPTIONS /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54654 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54656 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54655 - "OPTIONS /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54658 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54657 - "GET /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54654 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54655 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54657 - "GET /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54655 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54655 - "OPTIONS /api/submissions/23 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54655 - "DELETE /api/submissions/23 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54657 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54658 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54656 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54655 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54654 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54658 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54656 - "GET /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54678 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54680 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54681 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54677 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54679 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54677 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54681 - "GET /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54681 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54677 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54677 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54681 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54679 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54679 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54679 - "OPTIONS /api/jobs/start HTTP/1.1" 200 OK
2026-01-24 17:45:14,545 - genie_ops - INFO - Job job_4_1769273114 started: 1 submissions created for SaaS 4
INFO:     127.0.0.1:54681 - "POST /api/jobs/start HTTP/1.1" 200 OK
INFO:     127.0.0.1:54681 - "OPTIONS /api/jobs/process-all HTTP/1.1" 200 OK
INFO:     127.0.0.1:54679 - "POST /api/jobs/process-all HTTP/1.1" 200 OK
2026-01-24 17:45:14,563 - genie_ops - INFO - Processing submission 24 (attempt 1)
2026-01-24 17:45:14,594 - genie_ops - DEBUG - Using browser worker pool for operations
2026-01-24 17:45:14,594 - httpx - DEBUG - load_ssl_context verify=True cert=None trust_env=True http2=False
2026-01-24 17:45:14,598 - httpx - DEBUG - load_verify_locations cafile='D:\\blh khadmoni\\GENIE-OPS-Prototype\\backend\\venv\\Lib\\site-packages\\certifi\\cacert.pem'
2026-01-24 17:45:14,951 - genie_ops - INFO - Ollama client initialized. Model: llama3.2:3b, Base URL: http://localhost:11434
2026-01-24 17:45:14,952 - genie_ops - INFO - Starting submission workflow for http://localhost:5500/backend/test/test_form.html
2026-01-24 17:45:14,958 - genie_ops - INFO - Browser worker 0 initializing Playwright...
INFO:     127.0.0.1:54681 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54680 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54678 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54679 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54680 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54681 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54677 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54678 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54682 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54680 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54679 - "GET /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54677 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54682 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54679 - "GET /api/submissions/ HTTP/1.1" 200 OK
2026-01-24 17:45:16,068 - genie_ops - INFO - Browser worker 0 launching Chromium (headless=False)...
2026-01-24 17:45:17,133 - genie_ops - INFO - Browser worker 0 creating new page...
2026-01-24 17:45:17,582 - genie_ops - INFO - Browser worker 0 initialized successfully (headless=False, initial URL: about:blank)
2026-01-24 17:45:18,994 - genie_ops - INFO - Successfully navigated to http://localhost:5500/backend/test/test_form.html (final URL: http://localhost:5500/backend/test/test_form.html, status: 200)
2026-01-24 17:45:19,042 - genie_ops - INFO - Navigated to http://localhost:5500/backend/test/test_form.html (via worker pool) - Final URL: http://localhost:5500/backend/test/test_form.html, Status: 200
2026-01-24 17:45:19,046 - genie_ops - INFO - Browser worker 1 initializing Playwright...
2026-01-24 17:45:19,723 - genie_ops - INFO - Browser worker 1 launching Chromium (headless=False)...
2026-01-24 17:45:20,496 - genie_ops - INFO - Browser worker 1 creating new page...
2026-01-24 17:45:21,041 - genie_ops - INFO - Browser worker 1 initialized successfully (headless=False, initial URL: about:blank)
2026-01-24 17:45:21,757 - genie_ops - WARNING - Could not detect submission form, proceeding anyway
2026-01-24 17:45:21,762 - genie_ops - INFO - Browser worker 2 initializing Playwright...
2026-01-24 17:45:22,397 - genie_ops - INFO - Browser worker 2 launching Chromium (headless=False)...
2026-01-24 17:45:23,281 - genie_ops - INFO - Browser worker 2 creating new page...
2026-01-24 17:45:23,854 - genie_ops - INFO - Browser worker 2 initialized successfully (headless=False, initial URL: about:blank)
2026-01-24 17:45:23,855 - genie_ops - WARNING - Page was closed during detect_captcha, reinitializing for worker 2
2026-01-24 17:45:23,858 - genie_ops - DEBUG - Browser worker 2 browser already initialized and valid (URL: about:blank)
2026-01-24 17:45:24,158 - genie_ops - DEBUG - Retrieved page HTML (length: 8477 chars)
2026-01-24 17:45:24,159 - genie_ops - INFO - Analyzing form with llama3.2:3b (HTML length: 2092 chars)
2026-01-24 17:45:24,167 - httpcore.connection - DEBUG - connect_tcp.started host='localhost' port=11434 local_address=None timeout=None socket_options=None
2026-01-24 17:45:26,209 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x0000016A7A5FACD0>
2026-01-24 17:45:26,210 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2026-01-24 17:45:26,213 - httpcore.http11 - DEBUG - send_request_headers.complete
2026-01-24 17:45:26,216 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2026-01-24 17:45:26,217 - httpcore.http11 - DEBUG - send_request_body.complete
2026-01-24 17:45:26,217 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2026-01-24 17:45:47,922 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Content-Type', b'application/json; charset=utf-8'), (b'Date', b'Sat, 24 Jan 2026 16:45:47 GMT'), (b'Transfer-Encoding', b'chunked')])
2026-01-24 17:45:47,924 - httpx - INFO - HTTP Request: POST http://localhost:11434/api/chat "HTTP/1.1 200 OK"
2026-01-24 17:45:47,926 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2026-01-24 17:45:47,930 - httpcore.http11 - DEBUG - receive_response_body.complete
2026-01-24 17:45:47,931 - httpcore.http11 - DEBUG - response_closed.started
2026-01-24 17:45:47,932 - httpcore.http11 - DEBUG - response_closed.complete
2026-01-24 17:45:47,935 - genie_ops - INFO - Form analysis complete. Found 6 fields
2026-01-24 17:45:47,935 - genie_ops - INFO - Form analysis complete. Found 6 fields. Method: AI
2026-01-24 17:45:47,936 - genie_ops - INFO - Mapping SaaS data to 6 form fields
2026-01-24 17:45:47,937 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2026-01-24 17:45:47,939 - httpcore.http11 - DEBUG - send_request_headers.complete
2026-01-24 17:45:47,943 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2026-01-24 17:45:47,947 - httpcore.http11 - DEBUG - send_request_body.complete
2026-01-24 17:45:47,948 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2026-01-24 17:45:53,426 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Content-Type', b'application/json; charset=utf-8'), (b'Date', b'Sat, 24 Jan 2026 16:45:53 GMT'), (b'Content-Length', b'659')])
2026-01-24 17:45:53,427 - httpx - INFO - HTTP Request: POST http://localhost:11434/api/chat "HTTP/1.1 200 OK"
2026-01-24 17:45:53,429 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2026-01-24 17:45:53,430 - httpcore.http11 - DEBUG - receive_response_body.complete
2026-01-24 17:45:53,435 - httpcore.http11 - DEBUG - response_closed.started
2026-01-24 17:45:53,436 - httpcore.http11 - DEBUG - response_closed.complete
2026-01-24 17:45:53,437 - genie_ops - INFO - Data mapping complete. Mapped 4 fields
2026-01-24 17:45:53,438 - genie_ops - WARNING - Failed to set analysis_method field: 'NoneType' object has no attribute 'evaluate'
2026-01-24 17:45:53,439 - genie_ops - WARNING - Page was closed, reinitializing browser for worker 1
2026-01-24 17:45:53,440 - genie_ops - DEBUG - Browser worker 1 browser already initialized and valid (URL: about:blank)
2026-01-24 17:45:53,441 - genie_ops - INFO - Worker 1 attempting to fill 4 fields
INFO:     127.0.0.1:54762 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54763 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
2026-01-24 17:45:53,456 - genie_ops - DEBUG - Worker 1: Element not found for selector: #product_name
INFO:     127.0.0.1:54760 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54759 - "GET /api/saas HTTP/1.1" 200 OK
2026-01-24 17:45:53,473 - genie_ops - DEBUG - Worker 1: Element not found for selector: #website_url
INFO:     127.0.0.1:54761 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54763 - "GET /api/submissions/ HTTP/1.1" 200 OK
2026-01-24 17:45:53,493 - genie_ops - DEBUG - Worker 1: Element not found for selector: #contact_email
INFO:     127.0.0.1:54760 - "GET /api/directories/ HTTP/1.1" 200 OK
2026-01-24 17:45:53,508 - genie_ops - DEBUG - Worker 1: Element not found for selector: #description
2026-01-24 17:45:53,508 - genie_ops - INFO - Worker 1 fill_form complete: filled 0/4 fields, 4 errors
2026-01-24 17:45:53,509 - genie_ops - WARNING - Worker 1 fill_form errors: ['Element not found: #product_name', 'Element not found: #website_url', 'Element not found: #contact_email', 'Element not found: #description']
2026-01-24 17:45:53,552 - genie_ops - INFO - Filled form with 0 fields (via worker pool, attempt 1)
2026-01-24 17:45:53,552 - genie_ops - ERROR - No fields were filled
2026-01-24 17:45:53,556 - genie_ops - INFO - Submission 24 will be retried: Retry 1/3: Failed to fill any form fields
INFO:     127.0.0.1:54764 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54764 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54764 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54764 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54764 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54764 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54764 - "GET /api/submissions/ HTTP/1.1" 200 OK
2026-01-24 17:46:23,459 - genie_ops - INFO - Processing 1 pending submissions
2026-01-24 17:46:23,463 - genie_ops - INFO - Processing submission 24 (attempt 2)
2026-01-24 17:46:23,479 - genie_ops - DEBUG - Using browser worker pool for operations
2026-01-24 17:46:23,480 - httpx - DEBUG - load_ssl_context verify=True cert=None trust_env=True http2=False
2026-01-24 17:46:23,482 - httpx - DEBUG - load_verify_locations cafile='D:\\blh khadmoni\\GENIE-OPS-Prototype\\backend\\venv\\Lib\\site-packages\\certifi\\cacert.pem'
2026-01-24 17:46:23,793 - genie_ops - INFO - Ollama client initialized. Model: llama3.2:3b, Base URL: http://localhost:11434
2026-01-24 17:46:23,794 - genie_ops - INFO - Starting submission workflow for http://localhost:5500/backend/test/test_form.html
2026-01-24 17:46:25,196 - genie_ops - INFO - Successfully navigated to http://localhost:5500/backend/test/test_form.html (final URL: http://localhost:5500/backend/test/test_form.html, status: 200)
2026-01-24 17:46:25,217 - genie_ops - INFO - Navigated to http://localhost:5500/backend/test/test_form.html (via worker pool) - Final URL: http://localhost:5500/backend/test/test_form.html, Status: 200
2026-01-24 17:46:25,878 - genie_ops - INFO - Submission form detected successfully
2026-01-24 17:46:25,879 - genie_ops - WARNING - Page was closed during detect_captcha, reinitializing for worker 1
2026-01-24 17:46:25,881 - genie_ops - DEBUG - Browser worker 1 browser already initialized and valid (URL: about:blank)
2026-01-24 17:46:26,098 - genie_ops - DEBUG - Retrieved page HTML (length: 8477 chars)
2026-01-24 17:46:26,099 - genie_ops - INFO - Analyzing form with llama3.2:3b (HTML length: 2092 chars)
2026-01-24 17:46:26,103 - httpcore.connection - DEBUG - connect_tcp.started host='localhost' port=11434 local_address=None timeout=None socket_options=None
2026-01-24 17:46:28,118 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x0000016A7B980A10>
2026-01-24 17:46:28,119 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2026-01-24 17:46:28,124 - httpcore.http11 - DEBUG - send_request_headers.complete
2026-01-24 17:46:28,128 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2026-01-24 17:46:28,129 - httpcore.http11 - DEBUG - send_request_body.complete
2026-01-24 17:46:28,129 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2026-01-24 17:46:43,804 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Content-Type', b'application/json; charset=utf-8'), (b'Date', b'Sat, 24 Jan 2026 16:46:43 GMT'), (b'Transfer-Encoding', b'chunked')])
2026-01-24 17:46:43,805 - httpx - INFO - HTTP Request: POST http://localhost:11434/api/chat "HTTP/1.1 200 OK"
2026-01-24 17:46:43,811 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2026-01-24 17:46:43,817 - httpcore.http11 - DEBUG - receive_response_body.complete
2026-01-24 17:46:43,818 - httpcore.http11 - DEBUG - response_closed.started
2026-01-24 17:46:43,819 - httpcore.http11 - DEBUG - response_closed.complete
2026-01-24 17:46:43,826 - genie_ops - INFO - Form analysis complete. Found 6 fields
2026-01-24 17:46:43,827 - genie_ops - INFO - Form analysis complete. Found 6 fields. Method: AI
2026-01-24 17:46:43,828 - genie_ops - INFO - Mapping SaaS data to 6 form fields
2026-01-24 17:46:43,834 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2026-01-24 17:46:43,834 - httpcore.http11 - DEBUG - send_request_headers.complete
2026-01-24 17:46:43,835 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2026-01-24 17:46:43,837 - httpcore.http11 - DEBUG - send_request_body.complete
2026-01-24 17:46:43,838 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2026-01-24 17:46:49,669 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Content-Type', b'application/json; charset=utf-8'), (b'Date', b'Sat, 24 Jan 2026 16:46:49 GMT'), (b'Content-Length', b'727')])
2026-01-24 17:46:49,670 - httpx - INFO - HTTP Request: POST http://localhost:11434/api/chat "HTTP/1.1 200 OK"
2026-01-24 17:46:49,672 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2026-01-24 17:46:49,677 - httpcore.http11 - DEBUG - receive_response_body.complete
2026-01-24 17:46:49,678 - httpcore.http11 - DEBUG - response_closed.started
2026-01-24 17:46:49,679 - httpcore.http11 - DEBUG - response_closed.complete
2026-01-24 17:46:49,680 - genie_ops - INFO - Data mapping complete. Mapped 4 fields
2026-01-24 17:46:49,680 - genie_ops - WARNING - Failed to set analysis_method field: 'NoneType' object has no attribute 'evaluate'
2026-01-24 17:46:49,682 - genie_ops - WARNING - Page was closed, reinitializing browser for worker 0
2026-01-24 17:46:49,682 - genie_ops - DEBUG - Browser worker 0 browser already initialized and valid (URL: http://localhost:5500/backend/test/test_form.html)
INFO:     127.0.0.1:54782 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
2026-01-24 17:46:49,685 - genie_ops - INFO - Re-navigating to http://localhost:5500/backend/test/test_form.html after page was closed
INFO:     127.0.0.1:54781 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54779 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54780 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54778 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54781 - "GET /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54779 - "GET /api/directories/ HTTP/1.1" 200 OK
2026-01-24 17:46:51,052 - genie_ops - INFO - Successfully re-navigated to http://localhost:5500/backend/test/test_form.html
2026-01-24 17:46:51,053 - genie_ops - INFO - Worker 0 attempting to fill 4 fields
2026-01-24 17:46:51,082 - genie_ops - DEBUG - Worker 0: Found element for #product_name, attempting to fill with value: SayehOmar's Org
2026-01-24 17:46:51,142 - genie_ops - DEBUG - Worker 0: Element #product_name is input, type=text
2026-01-24 17:46:51,278 - genie_ops - DEBUG - Worker 0: Verified value set for #product_name: 'SayehOmar's Org'
2026-01-24 17:46:51,504 - genie_ops - DEBUG - Worker 0: Found element for #website_url, attempting to fill with value: https://www.linkedin.com/in/omar-sayeh-a0277b209/
2026-01-24 17:46:51,551 - genie_ops - DEBUG - Worker 0: Element #website_url is input, type=url
2026-01-24 17:46:51,685 - genie_ops - DEBUG - Worker 0: Verified value set for #website_url: 'https://www.linkedin.com/in/omar-sayeh-a0277b209/'
2026-01-24 17:46:51,911 - genie_ops - DEBUG - Worker 0: Found element for #contact_email, attempting to fill with value: sayehomar03@gmail.com
2026-01-24 17:46:51,952 - genie_ops - DEBUG - Worker 0: Element #contact_email is input, type=email
2026-01-24 17:46:52,087 - genie_ops - DEBUG - Worker 0: Verified value set for #contact_email: 'sayehomar03@gmail.com'
2026-01-24 17:46:52,319 - genie_ops - DEBUG - Worker 0: Found element for #description, attempting to fill with value: Hello world
2026-01-24 17:46:52,360 - genie_ops - DEBUG - Worker 0: Element #description is textarea, type=
2026-01-24 17:46:52,698 - genie_ops - INFO - Worker 0 fill_form complete: filled 4/4 fields, 0 errors
2026-01-24 17:46:52,763 - genie_ops - INFO - Filled form with 4 fields (via worker pool, attempt 1)
2026-01-24 17:46:53,774 - genie_ops - INFO - Worker 1: Attempting to submit using provided selector: button[type='submit']
2026-01-24 17:46:53,786 - genie_ops - WARNING - Worker 1: Submit button not found with selector: button[type='submit']
2026-01-24 17:46:53,787 - genie_ops - INFO - Worker 1: Trying common submit button selectors...
2026-01-24 17:46:53,866 - genie_ops - INFO - Worker 1: Attempting form submission via JavaScript (triggering button click)
2026-01-24 17:46:53,882 - genie_ops - WARNING - Worker 1: No form or button found for JavaScript submission
2026-01-24 17:46:56,900 - genie_ops - ERROR - Worker 1: Failed to submit form. Last error: No submit button found
2026-01-24 17:46:56,915 - genie_ops - WARNING - Submit form attempt 1 failed: Failed to submit form. Last error: No submit button found, retrying...
2026-01-24 17:46:58,960 - genie_ops - INFO - Worker 2: Attempting to submit using provided selector: button[type='submit']
2026-01-24 17:46:59,193 - genie_ops - INFO - Worker 2: Successfully clicked submit button using selector: button[type='submit']
2026-01-24 17:47:02,265 - genie_ops - INFO - Worker 2: Form submission completed successfully
2026-01-24 17:47:02,353 - genie_ops - INFO - Form submitted successfully (via worker pool, attempt 2)
2026-01-24 17:47:06,569 - genie_ops - WARNING - Worker 0: Error message element detected:
            Error! There was a problem submitting your product. Please try again.

2026-01-24 17:47:06,946 - genie_ops - INFO - Screenshot saved to ./storage/screenshots\submission_24_1769273183.png (via worker pool)
2026-01-24 17:47:06,947 - genie_ops - WARNING - Submission workflow completed with status: error
2026-01-24 17:47:06,964 - genie_ops - INFO - Submission 24 will be retried: Retry 2/3: Submission failed (error message detected):
            Error! There was a problem submitting your product. Please try again.

INFO:     127.0.0.1:54825 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54827 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54828 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54824 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54826 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54825 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54824 - "GET /api/submissions/ HTTP/1.1" 200 OK
2026-01-24 17:47:23,485 - genie_ops - INFO - Processing 1 pending submissions
2026-01-24 17:47:23,488 - genie_ops - INFO - Processing submission 24 (attempt 3)
2026-01-24 17:47:23,509 - genie_ops - DEBUG - Using browser worker pool for operations
2026-01-24 17:47:23,510 - httpx - DEBUG - load_ssl_context verify=True cert=None trust_env=True http2=False
2026-01-24 17:47:23,513 - httpx - DEBUG - load_verify_locations cafile='D:\\blh khadmoni\\GENIE-OPS-Prototype\\backend\\venv\\Lib\\site-packages\\certifi\\cacert.pem'
2026-01-24 17:47:23,973 - genie_ops - INFO - Ollama client initialized. Model: llama3.2:3b, Base URL: http://localhost:11434
2026-01-24 17:47:23,974 - genie_ops - INFO - Starting submission workflow for http://localhost:5500/backend/test/test_form.html
2026-01-24 17:47:25,349 - genie_ops - INFO - Successfully navigated to http://localhost:5500/backend/test/test_form.html (final URL: http://localhost:5500/backend/test/test_form.html, status: 200)
2026-01-24 17:47:25,400 - genie_ops - INFO - Navigated to http://localhost:5500/backend/test/test_form.html (via worker pool) - Final URL: http://localhost:5500/backend/test/test_form.html, Status: 200
2026-01-24 17:47:26,062 - genie_ops - INFO - Submission form detected successfully
2026-01-24 17:47:26,063 - genie_ops - WARNING - Page was closed during detect_captcha, reinitializing for worker 1
2026-01-24 17:47:26,070 - genie_ops - DEBUG - Browser worker 1 browser already initialized and valid (URL: about:blank)
2026-01-24 17:47:26,279 - genie_ops - DEBUG - Retrieved page HTML (length: 8477 chars)
2026-01-24 17:47:26,280 - genie_ops - INFO - Analyzing form with llama3.2:3b (HTML length: 2092 chars)
2026-01-24 17:47:26,287 - httpcore.connection - DEBUG - connect_tcp.started host='localhost' port=11434 local_address=None timeout=None socket_options=None
2026-01-24 17:47:28,331 - httpcore.connection - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x0000016A7B982550>
2026-01-24 17:47:28,331 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2026-01-24 17:47:28,336 - httpcore.http11 - DEBUG - send_request_headers.complete
2026-01-24 17:47:28,339 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2026-01-24 17:47:28,340 - httpcore.http11 - DEBUG - send_request_body.complete
2026-01-24 17:47:28,341 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2026-01-24 17:47:43,766 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Content-Type', b'application/json; charset=utf-8'), (b'Date', b'Sat, 24 Jan 2026 16:47:43 GMT'), (b'Transfer-Encoding', b'chunked')])
2026-01-24 17:47:43,766 - httpx - INFO - HTTP Request: POST http://localhost:11434/api/chat "HTTP/1.1 200 OK"
2026-01-24 17:47:43,770 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2026-01-24 17:47:43,773 - httpcore.http11 - DEBUG - receive_response_body.complete
2026-01-24 17:47:43,774 - httpcore.http11 - DEBUG - response_closed.started
2026-01-24 17:47:43,775 - httpcore.http11 - DEBUG - response_closed.complete
2026-01-24 17:47:43,779 - genie_ops - INFO - Form analysis complete. Found 6 fields
2026-01-24 17:47:43,780 - genie_ops - INFO - Form analysis complete. Found 6 fields. Method: AI
2026-01-24 17:47:43,780 - genie_ops - INFO - Mapping SaaS data to 6 form fields
2026-01-24 17:47:43,782 - httpcore.http11 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2026-01-24 17:47:43,783 - httpcore.http11 - DEBUG - send_request_headers.complete
2026-01-24 17:47:43,783 - httpcore.http11 - DEBUG - send_request_body.started request=<Request [b'POST']>
2026-01-24 17:47:43,783 - httpcore.http11 - DEBUG - send_request_body.complete
2026-01-24 17:47:43,784 - httpcore.http11 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2026-01-24 17:47:49,511 - httpcore.http11 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Content-Type', b'application/json; charset=utf-8'), (b'Date', b'Sat, 24 Jan 2026 16:47:49 GMT'), (b'Content-Length', b'732')])
2026-01-24 17:47:49,512 - httpx - INFO - HTTP Request: POST http://localhost:11434/api/chat "HTTP/1.1 200 OK"
2026-01-24 17:47:49,515 - httpcore.http11 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2026-01-24 17:47:49,519 - httpcore.http11 - DEBUG - receive_response_body.complete
2026-01-24 17:47:49,520 - httpcore.http11 - DEBUG - response_closed.started
2026-01-24 17:47:49,521 - httpcore.http11 - DEBUG - response_closed.complete
2026-01-24 17:47:49,524 - genie_ops - INFO - Data mapping complete. Mapped 4 fields
2026-01-24 17:47:49,525 - genie_ops - WARNING - Failed to set analysis_method field: 'NoneType' object has no attribute 'evaluate'
2026-01-24 17:47:49,527 - genie_ops - WARNING - Page was closed, reinitializing browser for worker 0
2026-01-24 17:47:49,528 - genie_ops - DEBUG - Browser worker 0 browser already initialized and valid (URL: http://localhost:5500/backend/test/test_form.html)
2026-01-24 17:47:49,529 - genie_ops - INFO - Re-navigating to http://localhost:5500/backend/test/test_form.html after page was closed
INFO:     127.0.0.1:54845 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54847 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54848 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54829 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54846 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54845 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54847 - "GET /api/submissions/ HTTP/1.1" 200 OK
2026-01-24 17:47:50,893 - genie_ops - INFO - Successfully re-navigated to http://localhost:5500/backend/test/test_form.html
2026-01-24 17:47:50,895 - genie_ops - INFO - Worker 0 attempting to fill 4 fields
2026-01-24 17:47:50,923 - genie_ops - DEBUG - Worker 0: Found element for #product_name, attempting to fill with value: SayehOmar's Org
2026-01-24 17:47:50,976 - genie_ops - DEBUG - Worker 0: Element #product_name is input, type=text
2026-01-24 17:47:51,126 - genie_ops - DEBUG - Worker 0: Verified value set for #product_name: 'SayehOmar's Org'
2026-01-24 17:47:51,358 - genie_ops - DEBUG - Worker 0: Found element for #website_url, attempting to fill with value: https://www.linkedin.com/in/omar-sayeh-a0277b209/
2026-01-24 17:47:51,405 - genie_ops - DEBUG - Worker 0: Element #website_url is input, type=url
2026-01-24 17:47:53,211 - genie_ops - DEBUG - Worker 0: Verified value set for #website_url: 'https://www.linkedin.com/in/omar-sayeh-a0277b209/'
2026-01-24 17:47:53,448 - genie_ops - DEBUG - Worker 0: Found element for #contact_email, attempting to fill with value: sayehomar03@gmail.com
2026-01-24 17:47:53,492 - genie_ops - DEBUG - Worker 0: Element #contact_email is input, type=email
2026-01-24 17:47:53,993 - genie_ops - DEBUG - Worker 0: Verified value set for #contact_email: 'sayehomar03@gmail.com'
2026-01-24 17:47:54,213 - genie_ops - DEBUG - Worker 0: Found element for #description, attempting to fill with value: Hello world
2026-01-24 17:47:54,267 - genie_ops - DEBUG - Worker 0: Element #description is textarea, type=
2026-01-24 17:47:54,640 - genie_ops - INFO - Worker 0 fill_form complete: filled 4/4 fields, 0 errors
2026-01-24 17:47:54,670 - genie_ops - INFO - Filled form with 4 fields (via worker pool, attempt 1)
2026-01-24 17:47:55,690 - genie_ops - INFO - Worker 1: Attempting to submit using provided selector: button[type='submit']
2026-01-24 17:47:55,701 - genie_ops - WARNING - Worker 1: Submit button not found with selector: button[type='submit']
2026-01-24 17:47:55,702 - genie_ops - INFO - Worker 1: Trying common submit button selectors...
2026-01-24 17:47:55,865 - genie_ops - INFO - Worker 1: Attempting form submission via JavaScript (triggering button click)
2026-01-24 17:47:55,883 - genie_ops - WARNING - Worker 1: No form or button found for JavaScript submission
2026-01-24 17:47:58,910 - genie_ops - ERROR - Worker 1: Failed to submit form. Last error: No submit button found
2026-01-24 17:47:58,957 - genie_ops - WARNING - Submit form attempt 1 failed: Failed to submit form. Last error: No submit button found, retrying...
2026-01-24 17:48:00,970 - genie_ops - INFO - Worker 2: Attempting to submit using provided selector: button[type='submit']
2026-01-24 17:48:01,140 - genie_ops - INFO - Worker 2: Successfully clicked submit button using selector: button[type='submit']
2026-01-24 17:48:04,207 - genie_ops - INFO - Worker 2: Form submission completed successfully
2026-01-24 17:48:04,230 - genie_ops - INFO - Form submitted successfully (via worker pool, attempt 2)
2026-01-24 17:48:08,469 - genie_ops - WARNING - Worker 0: Error message element detected:
            Error! There was a problem submitting your product. Please try again.

INFO:     127.0.0.1:54865 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54862 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54863 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54866 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54864 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54864 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54866 - "GET /api/submissions/ HTTP/1.1" 200 OK
2026-01-24 17:48:38,546 - genie_ops - ERROR - Browser worker 1 error handling take_screenshot: Timeout 30000ms exceeded.
Traceback (most recent call last):
  File "D:\blh khadmoni\GENIE-OPS-Prototype\backend\app\automation\browser_worker.py", line 177, in handle_command
    return await self._handle_take_screenshot(command.command_id, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\blh khadmoni\GENIE-OPS-Prototype\backend\app\automation\browser_worker.py", line 1058, in _handle_take_screenshot
    await self.page.screenshot(path=path, full_page=True)
  File "D:\blh khadmoni\GENIE-OPS-Prototype\backend\venv\Lib\site-packages\playwright\async_api\_generated.py", line 9983, in screenshot
    await self._impl_obj.screenshot(
  File "D:\blh khadmoni\GENIE-OPS-Prototype\backend\venv\Lib\site-packages\playwright\_impl\_page.py", line 657, in screenshot
    encoded_binary = await self._channel.send("screenshot", params)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\blh khadmoni\GENIE-OPS-Prototype\backend\venv\Lib\site-packages\playwright\_impl\_connection.py", line 62, in send
    return await self._connection.wrap_api_call(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "D:\blh khadmoni\GENIE-OPS-Prototype\backend\venv\Lib\site-packages\playwright\_impl\_connection.py", line 492, in wrap_api_call
    return await cb()
           ^^^^^^^^^^
  File "D:\blh khadmoni\GENIE-OPS-Prototype\backend\venv\Lib\site-packages\playwright\_impl\_connection.py", line 100, in inner_send
    result = next(iter(done)).result()
             ^^^^^^^^^^^^^^^^^^^^^^^^^
playwright._impl._errors.TimeoutError: Timeout 30000ms exceeded.

2026-01-24 17:48:38,599 - genie_ops - ERROR - Screenshot failed: Timeout 30000ms exceeded.
2026-01-24 17:48:38,608 - genie_ops - WARNING - Submission workflow completed with status: error
2026-01-24 17:48:38,610 - genie_ops - ERROR - Submission 24 failed after 3 attempts
INFO:     127.0.0.1:54868 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54868 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54868 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54868 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54868 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54868 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54868 - "GET /api/submissions/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54881 - "GET /api/directories HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54883 - "GET /api/jobs/workflow/status HTTP/1.1" 200 OK
INFO:     127.0.0.1:54884 - "GET /api/submissions HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:54880 - "GET /api/saas HTTP/1.1" 200 OK
INFO:     127.0.0.1:54882 - "GET /api/submissions/stats/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:54881 - "GET /api/directories/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:54884 - "GET /api/submissions/ HTTP/1.1" 200 OK

"""
Playwright browser automation (HANDS)
Handles browser interactions for form submissions
"""

import os
import time
import asyncio
from typing import Dict, List, Optional
from playwright.async_api import (
    async_playwright,
    Browser,
    Page,
    TimeoutError as PlaywrightTimeoutError,
)
from app.core.config import settings
from app.utils.logger import logger
from app.automation.browser_pool import get_browser_pool

# Optional import for URL file downloads
try:
    import aiohttp

    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False
    logger.warning("aiohttp not available. Logo URL downloads will be disabled.")


class BrowserAutomation:
    """
    Browser automation handler using Playwright.
    
    This class is the "Hands" of the system - it performs all browser interactions
    including navigation, form detection, field filling, file uploads, and form submission.
    It uses Playwright for reliable cross-browser automation with support for
    modern web features like dynamic content, modals, and JavaScript-heavy pages.
    
    Key capabilities:
    - Navigate to URLs and wait for page load
    - Detect submission forms (including modals and multi-step forms)
    - Fill text inputs, textareas, selects, and file uploads
    - Submit forms and verify success
    - Detect CAPTCHA presence
    - Take screenshots for debugging
    - Extract form fields using DOM inspection
    """

    def __init__(self):
        """
        Initialize the BrowserAutomation instance.
        
        Creates a new instance but doesn't start the browser yet. The browser
        is started lazily when needed (on first navigation or operation).
        Uses worker pool if available (Windows), otherwise uses direct Playwright.
        """
        self.browser: Browser = None
        self.page: Page = None
        self.playwright = None
        self.use_pool = False
        self.session_id: Optional[str] = None  # Session ID for worker assignment
        self._check_pool_availability()
    
    def _check_pool_availability(self):
        """
        Check if browser worker pool is available and should be used.
        
        The pool must be started (via start_browser_pool()) before it's available.
        This check happens when BrowserAutomation is instantiated.
        """
        try:
            pool = get_browser_pool()
            # Check if pool is configured to be used and is actually running
            self.use_pool = pool.use_pool and pool.is_available()
            if self.use_pool:
                logger.debug("Using browser worker pool for operations")
            else:
                logger.debug("Using direct Playwright (pool not available or not started)")
        except Exception as e:
            logger.warning(f"Could not check pool availability: {e}, using direct Playwright")
            self.use_pool = False
    
    def _refresh_pool_availability(self):
        """
        Refresh pool availability check.
        
        Useful if pool was started after BrowserAutomation was created.
        """
        if not self.use_pool:  # Only check if we're not already using pool
            self._check_pool_availability()

    async def start(self):
        """
        Start browser session
        """
        if not self.playwright:
            self.playwright = await async_playwright().start()

        self.browser = await self.playwright.chromium.launch(
            headless=settings.PLAYWRIGHT_HEADLESS,
            args=[
                "--no-sandbox",
                "--disable-setuid-sandbox",
            ],  # For better compatibility
        )
        self.page = await self.browser.new_page()

        # Set viewport size
        await self.page.set_viewport_size({"width": 1920, "height": 1080})

        logger.info("Browser session started")

    async def wait_for_page_load(self, timeout: int = 5000):
        """
        Wait for page to load (works with both pool and direct Playwright).
        
        When using worker pool, this is a no-op since the pool handles page state.
        When using direct Playwright, waits for the page to be ready.
        """
        if not self.use_pool and self.page:
            try:
                await self.page.wait_for_load_state("domcontentloaded", timeout=timeout)
            except:
                pass  # Ignore timeout, page might already be loaded
    
    async def wait_for_timeout(self, milliseconds: int):
        """
        Wait for specified milliseconds (works with both pool and direct Playwright).
        
        When using worker pool, this is a no-op since we can't directly wait.
        When using direct Playwright, waits for the specified time.
        """
        if not self.use_pool and self.page:
            await self.page.wait_for_timeout(milliseconds)
    
    async def get_current_url(self) -> str:
        """
        Get the current page URL (works with both pool and direct Playwright).
        
        Returns:
            Current URL, or empty string if not available
        """
        if self.use_pool:
            # Can't directly get URL from pool, return empty
            return ""
        elif self.page:
            return self.page.url
        else:
            return ""
    
    async def close(self):
        """
        Close browser session.
        
        Note: When using worker pool, browsers are managed by workers.
        This only closes direct Playwright instances.
        """
        if not self.use_pool:
            if self.page:
                await self.page.close()
            if self.browser:
                await self.browser.close()
            if self.playwright:
                await self.playwright.stop()
            logger.info("Browser session closed")

    async def navigate(self, url: str):
        """
        Navigate to a URL.
        
        Uses worker pool if available, otherwise uses direct Playwright.
        Raises exception if navigation fails.
        """
        # Refresh pool availability in case it was started after instance creation
        self._refresh_pool_availability()
        
        if self.use_pool:
            try:
                pool = get_browser_pool()
                result = await pool.execute_command(
                    "navigate",
                    {"url": url},
                    session_id=self.session_id
                )
                if result.status == "error":
                    error_msg = result.error or "Navigation failed"
                    logger.error(f"Navigation failed via worker pool: {error_msg}")
                    raise Exception(error_msg)
                
                # Log navigation details
                final_url = result.data.get("final_url", url)
                status = result.data.get("status", "unknown")
                logger.info(f"Navigated to {url} (via worker pool) - Final URL: {final_url}, Status: {status}")
                return
            except Exception as e:
                error_msg = str(e)
                # On Windows, don't fall back to direct Playwright (causes NotImplementedError)
                import platform
                if platform.system() == "Windows":
                    logger.error(f"Worker pool navigation failed on Windows: {error_msg}. Cannot fall back to direct Playwright.")
                    raise Exception(f"Navigation failed via worker pool: {error_msg}")
                else:
                    logger.warning(f"Worker pool navigation failed: {e}, falling back to direct Playwright")
                    self.use_pool = False
                    # Continue to direct Playwright path below
        
        # Direct Playwright path
        if not self.page:
            await self.start()

        try:
            response = await self.page.goto(
                url, timeout=settings.PLAYWRIGHT_TIMEOUT, wait_until="domcontentloaded"
            )
            
            # Verify navigation succeeded
            if response is None:
                raise Exception(f"Navigation to {url} returned None (page may not have loaded)")
            
            status = response.status
            if status >= 400:
                raise Exception(f"Navigation failed with HTTP {status}")
            
            final_url = self.page.url
            if not final_url or final_url == "about:blank":
                raise Exception(f"Navigation failed - page is blank or URL is invalid")
            
            logger.info(f"Navigated to {url} - Final URL: {final_url}, Status: {status}")
            
            # Wait a bit for page to fully load
            await self.page.wait_for_timeout(1000)
        
        except PlaywrightTimeoutError as e:
            logger.error(f"Navigation timeout to {url}: {e}")
            raise Exception(f"Navigation timeout: {str(e)}")
        except Exception as e:
            logger.error(f"Navigation error to {url}: {e}")
            raise

    async def detect_submission_page(self) -> bool:
        """
        Detect if we're on a submission page or need to navigate to it.
        
        This method intelligently detects submission forms on the current page. It looks for:
        - Form elements with input fields
        - Submission-related keywords in page text
        - Submit buttons and links
        - Modal forms that may need to be opened
        
        If a submission form is not found on the current page, it attempts to find and
        click submission links/buttons to navigate to the form page.
        
        Returns:
            True if submission form is detected (or navigation was successful)
            False if form could not be detected (but workflow continues anyway)
            
        Note: Enhanced to handle modals, multi-step forms, and dynamic content.
        Uses timeouts to prevent hanging on complex pages.
        """
        if self.use_pool:
            try:
                pool = get_browser_pool()
                result = await pool.execute_command("detect_submission_page", {}, session_id=self.session_id)
                if result.status == "error":
                    logger.warning(f"Submission page detection failed: {result.error}")
                    return False
                return result.data.get("detected", False)
            except Exception as e:
                logger.warning(f"Worker pool detect_submission_page failed: {e}, falling back to direct Playwright")
                self.use_pool = False
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        # Wait for page to be fully loaded (with shorter timeout for complex pages)
        try:
            await self.page.wait_for_load_state("domcontentloaded", timeout=3000)
        except PlaywrightTimeoutError:
            # Page might still be loading, continue anyway
            pass

        # Wait a bit for dynamic content (reduced timeout)
        await self.page.wait_for_timeout(500)

        # Look for common submission indicators (expanded list)
        submission_keywords = [
            "submit",
            "add listing",
            "add your",
            "submit your",
            "add product",
            "submit product",
            "new listing",
            "list your",
            "submit app",
            "add service",
            "submit website",
            "add business",
            "submit company",
            "register",
            "sign up",
        ]

        page_text = await self.page.inner_text("body")
        page_text_lower = page_text.lower()

        # Check for form elements (including forms in modals)
        form_count = await self.page.locator("form").count()
        input_count = await self.page.locator("input, textarea, select").count()

        # Check for modal forms
        modal_forms = await self.page.locator(
            "div[role='dialog'] form, .modal form, [class*='modal'] form"
        ).count()

        # Look for submission buttons (expanded selectors)
        submit_buttons = await self.page.locator(
            "button[type='submit'], input[type='submit'], "
            "button:has-text('submit'), button:has-text('add'), "
            "button:has-text('save'), button:has-text('register'), "
            "a:has-text('submit'), a:has-text('add listing'), "
            "a:has-text('list your')"
        ).count()

        # Check if any submission keywords are present
        has_keywords = any(
            keyword in page_text_lower for keyword in submission_keywords
        )

        # If we already have a form with inputs, we're likely on the submission page
        if form_count > 0 and input_count >= 2:
            logger.info("Submission form detected on current page")
            return True

        if modal_forms > 0:
            logger.info("Modal form detected")
            # Try to open modal if needed
            try:
                modal_triggers = await self.page.locator(
                    "button:has-text('Add'), button:has-text('Submit'), "
                    "a:has-text('Add'), [data-toggle='modal']"
                ).count()
                if modal_triggers > 0:
                    trigger = self.page.locator(
                        "button:has-text('Add'), button:has-text('Submit'), a:has-text('Add')"
                    ).first
                    await trigger.click()
                    await self.page.wait_for_timeout(1000)
                    logger.info("Opened modal form")
                    return True
            except Exception as e:
                logger.debug(f"Could not open modal: {str(e)}")

        if form_count > 0 or input_count > 3 or submit_buttons > 0 or has_keywords:
            logger.info("Submission page detected")
            return True

        # Try to find and click submission link/button (expanded selectors)
        # Limit search to prevent hanging on complex pages
        submission_selectors = [
            "a:has-text('Submit')",
            "a:has-text('Add Listing')",
            "a:has-text('Add Your')",
            "a:has-text('List Your')",
            "a:has-text('Submit Your')",
            "button:has-text('Submit')",
            "button:has-text('Add Listing')",
            "button:has-text('Add Your')",
            "[href*='submit']",
            "[href*='add']",
            "[href*='list']",
            "[href*='/submit']",
            "[href*='/add']",
        ]

        # Limit to first 5 selectors to prevent hanging on complex pages
        for selector in submission_selectors[:5]:
            try:
                element = self.page.locator(selector).first
                # Use shorter timeout for checking element count
                count = await element.count()
                if count > 0:
                    # Scroll into view
                    await element.scroll_into_view_if_needed()
                    await self.page.wait_for_timeout(300)
                    await element.click(timeout=2000)  # Add timeout to click
                    await self.page.wait_for_timeout(1000)  # Reduced wait time
                    logger.info(f"Clicked submission link: {selector}")

                    # Wait for new content to load (shorter timeout)
                    try:
                        await self.page.wait_for_load_state(
                            "domcontentloaded", timeout=3000
                        )
                    except:
                        pass

                    return True
            except Exception as e:
                logger.debug(f"Could not click {selector}: {str(e)}")
                continue

        logger.warning("Could not detect submission page, but proceeding anyway")
        return False  # Return False but workflow will continue

    async def fill_form(
        self, field_mappings: Dict[str, str], form_structure: Optional[Dict] = None
    ):
        """
        Fill form fields with provided data using CSS selectors.
        
        Iterates through the field mappings and fills each field with its corresponding
        value. Handles different field types appropriately:
        - Text inputs: Clear and fill with text
        - Textareas: Fill with text (supports multi-line)
        - Select dropdowns: Select by value or visible text
        - File inputs: Upload file from path or download from URL
        
        The method includes error handling for each field, so if one field fails,
        it continues with the others. All errors are collected and returned.
        
        Args:
            field_mappings: Dictionary mapping CSS selectors to values to fill:
                - Key: CSS selector (e.g., "#name", "[name='email']")
                - Value: Value to fill (string, or file path for file inputs)
            form_structure: Optional form structure from AI analysis (currently unused
                but available for future enhancements)
        
        Returns:
            Dictionary with fill results:
                - filled_count: Number of fields successfully filled
                - total_fields: Total number of fields in mappings
                - errors: List of error messages for failed fields
        """
        if self.use_pool:
            # Retry logic: try up to 2 times
            max_retries = 2
            last_error = None
            
            for attempt in range(max_retries):
                try:
                    pool = get_browser_pool()
                    result = await pool.execute_command(
                        "fill_form",
                        {"field_mappings": field_mappings},
                        session_id=self.session_id,
                        timeout=120  # 2 minutes for fill_form
                    )
                    if result.status == "error":
                        error_msg = result.error or "Form filling failed"
                        if attempt < max_retries - 1:
                            logger.warning(f"Fill form attempt {attempt + 1} failed: {error_msg}, retrying...")
                            last_error = error_msg
                            await asyncio.sleep(1)  # Brief delay before retry
                            continue
                        else:
                            raise Exception(error_msg)
                    
                    filled_count = result.data.get('filled_count', 0)
                    logger.info(f"Filled form with {filled_count} fields (via worker pool, attempt {attempt + 1})")
                    return result.data
                except Exception as e:
                    last_error = str(e)
                    if attempt < max_retries - 1:
                        logger.warning(f"Worker pool fill_form attempt {attempt + 1} failed: {e}, retrying...")
                        await asyncio.sleep(1)
                        continue
                    else:
                        logger.warning(f"Worker pool fill_form failed after {max_retries} attempts: {e}, falling back to direct Playwright")
                        self.use_pool = False
                        break
            
            if last_error:
                raise Exception(f"Fill form failed after {max_retries} attempts: {last_error}")
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        logger.info(f"Filling form with {len(field_mappings)} fields")

        filled_count = 0
        errors = []

        for selector, value in field_mappings.items():
            if not value:  # Skip empty values
                continue

            try:
                # Wait for element to be visible (with longer timeout for dynamic content)
                element = self.page.locator(selector).first

                # Try multiple strategies to find the element
                element_count = await element.count()
                if element_count == 0:
                    # Try alternative selectors if the main one fails
                    logger.debug(
                        f"Element not found with selector: {selector}, trying alternatives"
                    )
                    # The selector might need adjustment, but continue with original
                    errors.append(f"Element not found: {selector}")
                    continue

                # Get element type first (before checking visibility)
                tag_name = await element.evaluate("el => el.tagName.toLowerCase()")
                input_type = await element.get_attribute("type") or ""

                # Skip visibility check for hidden inputs
                if input_type != "hidden":
                    # Scroll element into view
                    await element.scroll_into_view_if_needed()
                    await element.wait_for(state="visible", timeout=5000)

                # Fill based on element type
                if tag_name == "input" and input_type == "file":
                    # Handle file upload - support both file paths and URLs
                    file_path = value

                    # Check if it's a URL (starts with http:// or https://)
                    if value.startswith(("http://", "https://")):
                        if not AIOHTTP_AVAILABLE:
                            logger.warning(
                                f"Cannot download logo from URL (aiohttp not available): {value}"
                            )
                            errors.append("Logo URL download requires aiohttp package")
                            continue

                        # Download the file first if it's a URL
                        import tempfile

                        try:
                            async with aiohttp.ClientSession() as session:
                                async with session.get(value) as response:
                                    if response.status == 200:
                                        # Create temp file
                                        file_ext = os.path.splitext(value)[1] or ".png"
                                        with tempfile.NamedTemporaryFile(
                                            delete=False, suffix=file_ext
                                        ) as tmp_file:
                                            tmp_file.write(await response.read())
                                            file_path = tmp_file.name
                                        logger.info(
                                            f"Downloaded logo from URL: {value}"
                                        )
                                    else:
                                        raise Exception(
                                            f"Failed to download file: HTTP {response.status}"
                                        )
                        except Exception as e:
                            logger.error(
                                f"Error downloading file from URL {value}: {str(e)}"
                            )
                            errors.append(f"Failed to download file from URL: {str(e)}")
                            continue

                    # Validate file exists and is a valid image type
                    if os.path.exists(file_path):
                        # Check file extension
                        valid_extensions = [
                            ".jpg",
                            ".jpeg",
                            ".png",
                            ".gif",
                            ".svg",
                            ".webp",
                            ".bmp",
                        ]
                        file_ext = os.path.splitext(file_path)[1].lower()

                        if file_ext in valid_extensions:
                            await element.set_input_files(file_path)
                            logger.info(f"Uploaded file: {file_path} to {selector}")
                            filled_count += 1

                            # Clean up temp file if it was downloaded
                            if value.startswith(
                                ("http://", "https://")
                            ) and os.path.exists(file_path):
                                try:
                                    os.unlink(file_path)
                                except:
                                    pass
                        else:
                            logger.warning(
                                f"Invalid file type: {file_ext}. Expected image file."
                            )
                            errors.append(f"Invalid file type: {file_ext}")
                    else:
                        logger.warning(f"File not found: {file_path}")
                        errors.append(f"File not found: {file_path}")

                elif tag_name == "textarea":
                    await element.fill(value)
                    logger.info(f"Filled textarea {selector} with: {value[:50]}...")
                    filled_count += 1

                elif tag_name == "select":
                    # Try to select by value or text
                    try:
                        await element.select_option(value)
                        logger.info(f"Selected option in {selector}: {value}")
                        filled_count += 1
                    except Exception:
                        # Try selecting by visible text
                        await element.select_option(label=value)
                        logger.info(f"Selected option by label in {selector}: {value}")
                        filled_count += 1

                elif tag_name == "input":
                    # Clear first, then fill
                    await element.clear()
                    await element.fill(value)
                    logger.info(f"Filled input {selector} with: {value[:50]}...")
                    filled_count += 1

                else:
                    # Try generic fill
                    await element.fill(value)
                    logger.info(f"Filled {tag_name} {selector} with: {value[:50]}...")
                    filled_count += 1

                # Small delay between fields
                await self.page.wait_for_timeout(200)

            except PlaywrightTimeoutError:
                logger.warning(f"Element not found or not visible: {selector}")
                errors.append(f"Element not found: {selector}")
            except Exception as e:
                logger.error(f"Error filling {selector}: {str(e)}")
                errors.append(f"Error filling {selector}: {str(e)}")

        logger.info(
            f"Form filling complete. Filled {filled_count} fields. Errors: {len(errors)}"
        )

        if errors:
            logger.warning(f"Form filling errors: {errors}")

        return {
            "filled_count": filled_count,
            "total_fields": len(field_mappings),
            "errors": errors,
        }

    async def submit_form(self, submit_button_selector: Optional[str] = None) -> bool:
        """
        Submit the form by clicking the submit button.
        
        Attempts to submit the form using the provided selector, or automatically
        detects the submit button if no selector is provided. Handles various
        submit button types and patterns commonly found on web forms.
        
        After clicking, waits for navigation or DOM changes to verify submission.
        For test forms that use preventDefault(), checks for success messages
        or form resets instead of navigation.
        
        Args:
            submit_button_selector: Optional CSS selector for the submit button.
                If not provided, automatically searches for common submit button patterns:
                - button[type='submit']
                - input[type='submit']
                - Buttons with text containing "Submit", "Add", "Save"
                - Common submit button IDs and classes
        
        Returns:
            True if form submission was attempted successfully
            False if submission failed (button not found, click failed, etc.)
        """
        if self.use_pool:
            # Retry logic: try up to 2 times
            max_retries = 2
            last_error = None
            
            for attempt in range(max_retries):
                try:
                    pool = get_browser_pool()
                    result = await pool.execute_command(
                        "submit_form",
                        {"submit_button_selector": submit_button_selector},
                        session_id=self.session_id,
                        timeout=30  # 30 seconds for submit
                    )
                    if result.status == "error":
                        error_msg = result.error or "Form submission failed"
                        if attempt < max_retries - 1:
                            logger.warning(f"Submit form attempt {attempt + 1} failed: {error_msg}, retrying...")
                            last_error = error_msg
                            await asyncio.sleep(1)
                            continue
                        else:
                            logger.error(f"Form submission failed after {max_retries} attempts: {error_msg}")
                            return False
                    
                    submitted = result.data.get("submitted", False)
                    if submitted:
                        logger.info(f"Form submitted successfully (via worker pool, attempt {attempt + 1})")
                        return True
                    elif attempt < max_retries - 1:
                        logger.warning(f"Submit form attempt {attempt + 1} returned not submitted, retrying...")
                        await asyncio.sleep(1)
                        continue
                    else:
                        logger.error("Form submission returned not submitted after all attempts")
                        return False
                except Exception as e:
                    last_error = str(e)
                    if attempt < max_retries - 1:
                        logger.warning(f"Worker pool submit_form attempt {attempt + 1} failed: {e}, retrying...")
                        await asyncio.sleep(1)
                        continue
                    else:
                        logger.warning(f"Worker pool submit_form failed after {max_retries} attempts: {e}, falling back to direct Playwright")
                        self.use_pool = False
                        break
            
            if last_error:
                logger.error(f"Submit form failed after {max_retries} attempts: {last_error}")
                return False
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        try:
            # Wait a bit before submitting
            await self.page.wait_for_timeout(500)

            if submit_button_selector:
                # Use provided selector
                try:
                    submit_button = self.page.locator(submit_button_selector).first
                    await submit_button.wait_for(state="visible", timeout=10000)
                    await submit_button.click()
                    logger.info(f"Clicked submit button: {submit_button_selector}")
                except Exception as e:
                    logger.warning(
                        f"Failed to click provided submit button {submit_button_selector}: {e}"
                    )
                    # Fall through to automatic detection
                    submit_button_selector = None

            if not submit_button_selector:
                # Try to find submit button automatically
                submit_selectors = [
                    "button[type='submit']",
                    "input[type='submit']",
                    "button:has-text('Submit Product')",  # Specific for test form
                    "button:has-text('Submit')",
                    "button:has-text('Add')",
                    "button:has-text('Save')",
                    "form button:last-child",  # Last button in form
                    "form input[type='submit']",
                    "#submitBtn",  # Common ID
                    "button.submit",  # Common class
                ]

                submitted = False
                for selector in submit_selectors:
                    try:
                        button = self.page.locator(selector).first
                        count = await button.count()
                        if count > 0:
                            await button.wait_for(state="visible", timeout=5000)
                            await button.click()
                            logger.info(f"Clicked submit button: {selector}")
                            submitted = True
                            break
                    except Exception as e:
                        logger.debug(f"Selector {selector} failed: {e}")
                        continue

                if not submitted:
                    # Try submitting the form directly
                    try:
                        await self.page.evaluate(
                            "document.querySelector('form')?.submit()"
                        )
                        logger.info("Submitted form directly via JavaScript")
                        submitted = True
                    except Exception as e:
                        logger.warning(f"Direct form submission failed: {e}")

            # Wait for navigation or response
            # For test forms that use preventDefault(), wait for DOM changes instead
            try:
                # Wait a bit for any JavaScript handlers to run
                await self.page.wait_for_timeout(1000)

                # Check if page navigated
                try:
                    await self.page.wait_for_load_state("networkidle", timeout=5000)
                except PlaywrightTimeoutError:
                    # Page might not navigate (e.g., test form with preventDefault)
                    # Check if success message appeared or form was reset
                    try:
                        # Wait for any success indicators or form changes
                        await self.page.wait_for_timeout(1000)
                    except:
                        pass
            except Exception as e:
                logger.warning(f"Timeout waiting for navigation: {str(e)}")
                # Still consider it successful if we got here

            logger.info("Form submitted successfully")
            return True

        except Exception as e:
            logger.error(f"Form submission failed: {str(e)}")
            return False

    async def wait_for_confirmation(self, timeout: int = 10000) -> Dict[str, any]:
        """
        Wait for submission confirmation or error message.
        Returns status and message.
        
        Uses worker pool if available, otherwise uses direct Playwright.
        """
        if self.use_pool:
            try:
                pool = get_browser_pool()
                result = await pool.execute_command("wait_for_confirmation", {"timeout": timeout}, session_id=self.session_id)
                if result.status == "error":
                    return {
                        "status": "unknown",
                        "message": result.error or "Confirmation check failed",
                        "url": ""
                    }
                return result.data
            except Exception as e:
                logger.warning(f"Worker pool wait_for_confirmation failed: {e}, falling back to direct Playwright")
                self.use_pool = False
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        try:
            # Wait for page changes
            await self.page.wait_for_timeout(2000)

            # Look for success indicators
            success_keywords = [
                "thank you",
                "success",
                "submitted",
                "received",
                "confirmation",
                "approved",
                "pending review",
            ]

            # Look for error indicators
            error_keywords = [
                "error",
                "failed",
                "invalid",
                "required",
                "captcha",
                "verification",
            ]

            page_text = (await self.page.inner_text("body")).lower()
            current_url = self.page.url

            # Check for success message element (common in test forms)
            try:
                success_elements = await self.page.locator(
                    "#successMessage, .success, [class*='success']"
                ).count()
                if success_elements > 0:
                    logger.info("Success message element detected")
                    return {
                        "status": "success",
                        "message": "Submission successful (success message detected)",
                        "url": current_url,
                    }
            except:
                pass

            # Check for success
            for keyword in success_keywords:
                if keyword in page_text:
                    logger.info(f"Success detected: {keyword}")
                    return {
                        "status": "success",
                        "message": f"Submission successful (detected: {keyword})",
                        "url": current_url,
                    }

            # Check for errors
            for keyword in error_keywords:
                if keyword in page_text:
                    logger.warning(f"Error detected: {keyword}")
                    return {
                        "status": "error",
                        "message": f"Submission may have failed (detected: {keyword})",
                        "url": current_url,
                    }

            # Check URL change (might indicate success)
            if "submit" not in current_url.lower() and "add" not in current_url.lower():
                logger.info("URL changed, possible success")
                return {
                    "status": "success",
                    "message": "URL changed after submission",
                    "url": current_url,
                }

            # Default: assume pending
            return {
                "status": "pending",
                "message": "Submission status unclear",
                "url": current_url,
            }

        except Exception as e:
            logger.error(f"Error waiting for confirmation: {str(e)}")
            current_url = ""
            if not self.use_pool and self.page:
                current_url = self.page.url
            return {
                "status": "unknown",
                "message": f"Error: {str(e)}",
                "url": current_url,
            }

    async def detect_captcha(self) -> bool:
        """
        Detect if CAPTCHA is present on the page.
        
        Checks for common CAPTCHA implementations including:
        - reCAPTCHA (Google)
        - hCaptcha
        - Custom CAPTCHA implementations
        
        This is a safety feature to prevent the system from attempting to
        submit forms that require human verification. When CAPTCHA is detected,
        the submission is marked as failed with a specific error message.
        
        Returns:
            True if CAPTCHA is detected on the page
            False if no CAPTCHA is found
        """
        if self.use_pool:
            try:
                pool = get_browser_pool()
                result = await pool.execute_command("detect_captcha", {})
                if result.status == "error":
                    logger.warning(f"CAPTCHA detection failed: {result.error}")
                    return False
                return result.data.get("has_captcha", False)
            except Exception as e:
                logger.warning(f"Worker pool detect_captcha failed: {e}, falling back to direct Playwright")
                self.use_pool = False
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        captcha_selectors = [
            "iframe[src*='recaptcha']",
            "iframe[src*='hcaptcha']",
            ".g-recaptcha",
            "#captcha",
            "[data-sitekey]",  # reCAPTCHA site key
            "img[alt*='captcha']",
            "img[alt*='CAPTCHA']",
        ]

        for selector in captcha_selectors:
            try:
                element = self.page.locator(selector).first
                if await element.count() > 0:
                    logger.warning(f"CAPTCHA detected: {selector}")
                    return True
            except Exception:
                continue

        # Also check page text
        page_text = (await self.page.inner_text("body")).lower()
        if "captcha" in page_text or "verify you are human" in page_text:
            logger.warning("CAPTCHA detected in page text")
            return True

        return False

    async def take_screenshot(self, path: str):
        """
        Take a screenshot.
        
        Uses worker pool if available, otherwise uses direct Playwright.
        """
        if self.use_pool:
            try:
                pool = get_browser_pool()
                result = await pool.execute_command("take_screenshot", {"path": path}, session_id=self.session_id)
                if result.status == "error":
                    logger.error(f"Screenshot failed: {result.error}")
                else:
                    logger.info(f"Screenshot saved to {path} (via worker pool)")
                return
            except Exception as e:
                logger.warning(f"Worker pool take_screenshot failed: {e}, falling back to direct Playwright")
                self.use_pool = False
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        # Ensure directory exists
        os.makedirs(
            os.path.dirname(path) if os.path.dirname(path) else ".", exist_ok=True
        )

        await self.page.screenshot(path=path, full_page=True)
        logger.info(f"Screenshot saved to {path}")

    async def get_page_content(self) -> str:
        """
        Get the current page HTML content.
        
        Uses worker pool if available, otherwise uses direct Playwright.
        """
        if self.use_pool:
            try:
                pool = get_browser_pool()
                result = await pool.execute_command("get_page_content", {})
                if result.status == "error":
                    raise Exception(result.error or "Failed to get page content")
                return result.data.get("content", "")
            except Exception as e:
                logger.warning(f"Worker pool get_page_content failed: {e}, falling back to direct Playwright")
                self.use_pool = False
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        return await self.page.content()

    async def extract_form_fields_dom(self) -> Dict:
        """
        Extract form fields using DOM inspection (no AI needed).
        Returns structured form data compatible with AI output format.
        
        Uses worker pool if available, otherwise uses direct Playwright.

        Returns:
            Dict with fields, submit_button, and form_selector
        """
        if self.use_pool:
            try:
                pool = get_browser_pool()
                result = await pool.execute_command("extract_form_fields_dom", {}, session_id=self.session_id)
                if result.status == "error":
                    logger.error(f"DOM extraction failed: {result.error}")
                    return {
                        "fields": [],
                        "submit_button": None,
                        "form_selector": "form",
                        "error": result.error
                    }
                return result.data
            except Exception as e:
                logger.warning(f"Worker pool extract_form_fields_dom failed: {e}, falling back to direct Playwright")
                self.use_pool = False
        
        # Direct Playwright path
        if not self.page:
            raise Exception("Browser not started")

        logger.info("Extracting form fields using DOM inspection")

        try:
            # Wait for page to be ready (with timeout to prevent hanging)
            try:
                await self.page.wait_for_load_state("domcontentloaded", timeout=5000)
            except PlaywrightTimeoutError:
                logger.warning("Page load timeout, proceeding with extraction anyway")
                # Continue anyway - page might be complex

            # Wait a bit more for dynamic content
            await self.page.wait_for_timeout(1000)

            # First, check if form exists and wait for it if needed
            try:
                # Wait for form to appear (with timeout)
                await self.page.wait_for_selector("form", timeout=5000)
                logger.debug("Form element found on page")

                # Also wait for at least one input field to be present (form might be empty)
                try:
                    await self.page.wait_for_selector(
                        "input:not([type='hidden']), textarea, select", timeout=3000
                    )
                    logger.debug("Form fields found on page")
                except PlaywrightTimeoutError:
                    logger.warning(
                        "Form found but no visible input fields detected yet, waiting longer..."
                    )
                    # Wait a bit more for dynamic content
                    await self.page.wait_for_timeout(2000)
            except PlaywrightTimeoutError:
                logger.warning(
                    "No form element found, checking for input fields directly"
                )
                # Try waiting for any input field instead
                try:
                    await self.page.wait_for_selector(
                        "input:not([type='hidden']), textarea, select", timeout=3000
                    )
                    logger.debug("Input fields found on page (no form tag)")
                except PlaywrightTimeoutError:
                    logger.error("No form or input fields found on page after waiting")
                    # Take a screenshot for debugging
                    try:
                        debug_screenshot = f"./storage/screenshots/debug_no_form_{int(time.time())}.png"
                        os.makedirs(os.path.dirname(debug_screenshot), exist_ok=True)
                        await self.page.screenshot(
                            path=debug_screenshot, full_page=True
                        )
                        logger.info(f"Debug screenshot saved to {debug_screenshot}")
                    except:
                        pass

            # Extract form fields using JavaScript (with timeout)
            form_data = await self.page.evaluate(
                """
                () => {
                    const fields = [];
                    const forms = document.querySelectorAll('form');
                    let mainForm = forms[0] || document.body;
                    
                    // Find all input, textarea, and select elements
                    const formElements = mainForm.querySelectorAll('input, textarea, select');
                    
                    formElements.forEach((el, index) => {
                        // Skip hidden fields (they're not user-fillable)
                        // But we'll still count them for debugging
                        const isHidden = el.type === 'hidden';
                        if (isHidden) {
                            console.log('Skipping hidden field:', el.name || el.id || 'unnamed');
                            return;
                        }
                        
                        const tagName = el.tagName.toLowerCase();
                        const type = el.type || '';
                        const name = el.name || el.id || '';
                        const id = el.id || '';
                        const placeholder = el.placeholder || '';
                        const label = el.labels && el.labels[0] ? el.labels[0].textContent.trim() : '';
                        
                        // Try to find associated label
                        let labelText = label;
                        if (!labelText && id) {
                            const labelEl = document.querySelector(`label[for="${id}"]`);
                            if (labelEl) labelText = labelEl.textContent.trim();
                        }
                        if (!labelText && name) {
                            const labelEl = document.querySelector(`label[for="${name}"]`);
                            if (labelEl) labelText = labelEl.textContent.trim();
                        }
                        
                        // Generate selector (prefer ID, then name, then fallback)
                        let selector = '';
                        if (id) {
                            selector = `#${id}`;
                        } else if (name) {
                            selector = `[name="${name}"]`;
                        } else {
                            selector = `${tagName}[type="${type}"]:nth-of-type(${index + 1})`;
                        }
                        
                        // Determine if required
                        const required = el.hasAttribute('required') || 
                                       el.getAttribute('aria-required') === 'true';
                        
                        // Infer purpose from name, id, label, placeholder
                        const fieldText = (name + ' ' + id + ' ' + labelText + ' ' + placeholder).toLowerCase();
                        let purpose = 'other';
                        if (fieldText.match(/name|title|product|company|business/)) {
                            purpose = 'name';
                        } else if (fieldText.match(/url|website|site|link|homepage|domain/)) {
                            purpose = 'url';
                        } else if (fieldText.match(/email|mail|contact.*email/)) {
                            purpose = 'email';
                        } else if (fieldText.match(/description|desc|about|details|info|summary/)) {
                            purpose = 'description';
                        } else if (fieldText.match(/category|tag|tags|type|industry/)) {
                            purpose = 'category';
                        } else if (fieldText.match(/logo|image|picture|photo|icon/)) {
                            purpose = 'logo';
                        }
                        
                        // Get options for select elements
                        let options = [];
                        if (tagName === 'select') {
                            options = Array.from(el.options).map(opt => opt.text || opt.value);
                        }
                        
                        fields.push({
                            selector: selector,
                            type: type || tagName,
                            name: name || id || '',
                            label: labelText,
                            placeholder: placeholder,
                            required: required,
                            purpose: purpose,
                            options: options.length > 0 ? options : undefined
                        });
                    });
                    
                    // Find submit button
                    let submitButton = null;
                    const submitSelectors = [
                        'button[type="submit"]',
                        'input[type="submit"]',
                        'button:contains("Submit")',
                        'button:contains("Add")',
                        'button:contains("Save")'
                    ];
                    
                    for (const sel of submitSelectors) {
                        const btn = mainForm.querySelector(sel);
                        if (btn) {
                            const btnId = btn.id || '';
                            const btnName = btn.name || '';
                            submitButton = {
                                selector: btnId ? `#${btnId}` : (btnName ? `[name="${btnName}"]` : sel),
                                text: btn.textContent?.trim() || btn.value || ''
                            };
                            break;
                        }
                    }
                    
                    // If no submit button found, try to find any button in form
                    if (!submitButton) {
                        const anyButton = mainForm.querySelector('button, input[type="button"]');
                        if (anyButton) {
                            const btnId = anyButton.id || '';
                            submitButton = {
                                selector: btnId ? `#${btnId}` : 'button:first-of-type',
                                text: anyButton.textContent?.trim() || anyButton.value || ''
                            };
                        }
                    }
                    
                    // Get form selector
                    const formSelector = forms[0] ? 
                        (forms[0].id ? `#${forms[0].id}` : (forms[0].name ? `form[name="${forms[0].name}"]` : 'form')) :
                        'body';
                    
                    // Log diagnostic info
                    console.log('Form extraction complete:', {
                        formCount: forms.length,
                        totalElements: formElements.length,
                        extractedFields: fields.length,
                        formSelector: formSelector
                    });
                    
                    return {
                        fields: fields,
                        submit_button: submitButton,
                        form_selector: formSelector
                    };
                }
            """
            )

            field_count = len(form_data.get("fields", []))
            logger.info(f"Extracted {field_count} form fields using DOM inspection")

            # If no fields found, log diagnostic information
            if field_count == 0:
                logger.warning("No form fields extracted. Running diagnostics...")
                # Get diagnostic info
                diagnostic = await self.page.evaluate(
                    """
                    () => {
                        const forms = document.querySelectorAll('form');
                        const inputs = document.querySelectorAll('input, textarea, select');
                        const bodyText = document.body ? document.body.innerText.substring(0, 200) : '';
                        return {
                            formCount: forms.length,
                            inputCount: inputs.length,
                            hasBody: !!document.body,
                            bodyTextPreview: bodyText,
                            url: window.location.href
                        };
                    }
                """
                )
                logger.warning(f"Diagnostics: {diagnostic}")

                # Take screenshot for debugging
                try:
                    debug_screenshot = (
                        f"./storage/screenshots/debug_no_fields_{int(time.time())}.png"
                    )
                    os.makedirs(os.path.dirname(debug_screenshot), exist_ok=True)
                    await self.page.screenshot(path=debug_screenshot, full_page=True)
                    logger.info(f"Debug screenshot saved to {debug_screenshot}")
                except Exception as screenshot_error:
                    logger.warning(
                        f"Failed to take debug screenshot: {screenshot_error}"
                    )

            return form_data

        except Exception as e:
            logger.error(f"Error extracting form fields: {str(e)}", exc_info=True)
            # Take error screenshot
            try:
                error_screenshot = (
                    f"./storage/screenshots/error_extraction_{int(time.time())}.png"
                )
                os.makedirs(os.path.dirname(error_screenshot), exist_ok=True)
                await self.page.screenshot(path=error_screenshot, full_page=True)
                logger.info(f"Error screenshot saved to {error_screenshot}")
            except:
                pass
            return {
                "fields": [],
                "submit_button": None,
                "form_selector": "form",
                "error": f"DOM extraction failed: {str(e)}",
            }

"""
Browser worker process that runs Playwright in isolation.

This module runs in a separate process to avoid Windows threading issues.
Each worker process handles one browser operation at a time.
"""
import os
import sys
import asyncio
import traceback
from typing import Dict, Any, Optional
from multiprocessing import Queue
from playwright.async_api import async_playwright, Browser, Page, TimeoutError as PlaywrightTimeoutError
from app.core.config import settings
from app.automation.commands import BrowserCommand, BrowserResult
from app.utils.logger import logger

# Optional import for URL file downloads
try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False


class BrowserWorker:
    """
    Browser worker that runs in a separate process.
    
    This worker handles all Playwright operations in isolation,
    avoiding Windows threading issues. It receives commands via
    a queue and returns results via another queue.
    """
    
    def __init__(self, command_queue: Queue, result_queue: Queue, worker_id: int):
        """
        Initialize the browser worker.
        
        Args:
            command_queue: Queue to receive commands from main process
            result_queue: Queue to send results back to main process
            worker_id: Unique identifier for this worker
        """
        self.command_queue = command_queue
        self.result_queue = result_queue
        self.worker_id = worker_id
        self.playwright = None
        self.browser: Optional[Browser] = None
        self.page: Optional[Page] = None
        self.current_url: Optional[str] = None  # Track current URL to re-navigate if page closes
        self.is_running = False
    
    async def initialize_browser(self):
        """
        Initialize Playwright and browser instance.
        Called lazily on first command or when page is closed.
        """
        # Clean up existing browser if it exists but is invalid
        if self.page:
            try:
                # Test if page is still valid by checking URL
                _ = self.page.url
                # Page is valid, no need to reinitialize
                logger.debug(f"Browser worker {self.worker_id} browser already initialized and valid (URL: {self.page.url})")
                return
            except Exception as e:
                # Page is invalid, clean up before reinitializing
                logger.warning(f"Browser worker {self.worker_id} existing page is invalid ({str(e)}), cleaning up...")
                try:
                    await self.cleanup_browser(full_cleanup=False)  # Keep browser alive, just close page
                except:
                    pass  # Ignore cleanup errors
        
        try:
            logger.info(f"Browser worker {self.worker_id} initializing Playwright...")
            if not self.playwright:
                self.playwright = await async_playwright().start()
            
            logger.info(f"Browser worker {self.worker_id} launching Chromium (headless={settings.PLAYWRIGHT_HEADLESS})...")
            if not self.browser:
                self.browser = await self.playwright.chromium.launch(
                    headless=settings.PLAYWRIGHT_HEADLESS,
                    args=[
                        "--no-sandbox",
                        "--disable-setuid-sandbox",
                    ],
                )
            
            logger.info(f"Browser worker {self.worker_id} creating new page...")
            # Close old page if it exists but is invalid (shouldn't happen after cleanup, but just in case)
            if self.page:
                try:
                    await self.page.close()
                except:
                    pass
                self.page = None
            
            self.page = await self.browser.new_page()
            await self.page.set_viewport_size({"width": 1920, "height": 1080})
            
            # Set up page event listeners to detect if page closes unexpectedly
            def on_page_close(page):
                logger.warning(f"Browser worker {self.worker_id} page closed unexpectedly")
                self.page = None
            
            self.page.on("close", on_page_close)
            
            # Verify page is ready
            current_url = self.page.url
            logger.info(f"Browser worker {self.worker_id} initialized successfully (headless={settings.PLAYWRIGHT_HEADLESS}, initial URL: {current_url})")
        except Exception as e:
            logger.error(f"Browser worker {self.worker_id} initialization failed: {e}")
            import traceback
            traceback.print_exc()
            raise
    
    async def cleanup_browser(self, full_cleanup: bool = False):
        """
        Clean up browser resources.
        
        Args:
            full_cleanup: If True, closes browser and playwright (on shutdown).
                         If False, only closes page (for page reinitialization).
        """
        try:
            if self.page:
                try:
                    # Check if page is still valid before closing
                    _ = self.page.url
                    await self.page.close()
                except:
                    pass  # Page already closed or invalid
                self.page = None
            
            if full_cleanup:
                # Full cleanup on shutdown
                if self.browser:
                    await self.browser.close()
                    self.browser = None
                if self.playwright:
                    await self.playwright.stop()
                    self.playwright = None
                logger.info(f"Browser worker {self.worker_id} fully cleaned up")
            else:
                # Partial cleanup - just page, keep browser alive
                logger.debug(f"Browser worker {self.worker_id} page cleaned up (browser kept alive)")
        except Exception as e:
            logger.error(f"Error cleaning up browser worker {self.worker_id}: {e}")
    
    async def handle_command(self, command: BrowserCommand) -> BrowserResult:
        """
        Handle a browser command and return result.
        
        Args:
            command: BrowserCommand to execute
            
        Returns:
            BrowserResult with command execution result
        """
        try:
            command_type = command.command_type
            params = command.params
            
            if command_type == "navigate":
                return await self._handle_navigate(command.command_id, params)
            elif command_type == "fill_form":
                return await self._handle_fill_form(command.command_id, params)
            elif command_type == "submit_form":
                return await self._handle_submit_form(command.command_id, params)
            elif command_type == "detect_captcha":
                return await self._handle_detect_captcha(command.command_id, params)
            elif command_type == "get_page_content":
                return await self._handle_get_page_content(command.command_id, params)
            elif command_type == "extract_form_fields_dom":
                return await self._handle_extract_form_fields_dom(command.command_id, params)
            elif command_type == "take_screenshot":
                return await self._handle_take_screenshot(command.command_id, params)
            elif command_type == "detect_submission_page":
                return await self._handle_detect_submission_page(command.command_id, params)
            elif command_type == "wait_for_confirmation":
                return await self._handle_wait_for_confirmation(command.command_id, params)
            elif command_type == "close":
                return await self._handle_close(command.command_id, params)
            else:
                return BrowserResult.error_result(
                    command.command_id,
                    f"Unknown command type: {command_type}",
                    "UnknownCommandError"
                )
        except Exception as e:
            error_msg = str(e)
            error_trace = traceback.format_exc()
            logger.error(f"Browser worker {self.worker_id} error handling {command.command_type}: {error_msg}\n{error_trace}")
            return BrowserResult.error_result(
                command.command_id,
                error_msg,
                type(e).__name__
            )
    
    async def _handle_navigate(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle navigate command"""
        # Initialize browser lazily on first navigation command
        if not self.page or not self.browser:
            try:
                await self.initialize_browser()
            except Exception as e:
                logger.error(f"Browser worker {self.worker_id} failed to initialize: {e}")
                return BrowserResult.error_result(
                    command_id,
                    f"Failed to initialize browser: {str(e)}",
                    "BrowserInitFailed"
                )
        
        # Verify page is still valid
        try:
            _ = self.page.url
        except Exception:
            # Page was closed, reinitialize
            logger.warning(f"Browser worker {self.worker_id} page was closed, reinitializing...")
            try:
                await self.initialize_browser()
            except Exception as e:
                return BrowserResult.error_result(
                    command_id,
                    f"Failed to reinitialize browser: {str(e)}",
                    "BrowserReinitFailed"
                )
        
        url = params.get("url")
        if not url:
            return BrowserResult.error_result(command_id, "No URL provided", "MissingURL")
        
        try:
            # Navigate with proper error handling
            response = await self.page.goto(
                url, 
                timeout=settings.PLAYWRIGHT_TIMEOUT, 
                wait_until="domcontentloaded"
            )
            
            # Verify navigation actually succeeded
            if response is None:
                return BrowserResult.error_result(
                    command_id, 
                    f"Navigation to {url} returned None (page may not have loaded)",
                    "NavigationFailed"
                )
            
            # Check response status
            status = response.status
            if status >= 400:
                return BrowserResult.error_result(
                    command_id,
                    f"Navigation failed with HTTP {status}",
                    f"HTTPError{status}"
                )
            
            # Verify we're actually on the target URL (or redirected to it)
            final_url = self.page.url
            if not final_url or final_url == "about:blank":
                return BrowserResult.error_result(
                    command_id,
                    f"Navigation failed - page is blank or URL is invalid",
                    "InvalidPageState"
                )
            
            # Wait for page to be ready
            await self.page.wait_for_timeout(1000)
            
            # Get page title and basic info for verification
            try:
                page_title = await self.page.title()
            except:
                page_title = "Unknown"
            
            logger.info(f"Successfully navigated to {url} (final URL: {final_url}, status: {status})")
            
            # Store current URL for potential re-navigation
            self.current_url = final_url
            
            return BrowserResult.success(command_id, {
                "url": url,
                "final_url": final_url,
                "status": status,
                "title": page_title
            })
        
        except PlaywrightTimeoutError as e:
            return BrowserResult.error_result(
                command_id,
                f"Navigation timeout: {str(e)}",
                "TimeoutError"
            )
        except Exception as e:
            error_msg = str(e)
            logger.error(f"Navigation error: {error_msg}")
            return BrowserResult.error_result(
                command_id,
                f"Navigation failed: {error_msg}",
                type(e).__name__
            )
    
    async def _handle_fill_form(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle fill_form command"""
        # Check if page exists and is still open
        if not self.page:
            # Try to reinitialize
            try:
                await self.initialize_browser()
            except Exception as e:
                return BrowserResult.error_result(
                    command_id, 
                    f"Browser not initialized and reinitialization failed: {str(e)}", 
                    "BrowserNotInitialized"
                )
        
        # Verify page is still open
        try:
            # Quick check to see if page is still valid
            await self.page.url
        except Exception as e:
            # Page was closed, reinitialize and re-navigate if we have a URL
            logger.warning(f"Page was closed, reinitializing browser for worker {self.worker_id}")
            try:
                await self.initialize_browser()
                # Re-navigate if we have a stored URL
                if self.current_url:
                    logger.info(f"Re-navigating to {self.current_url} after page was closed")
                    try:
                        response = await self.page.goto(
                            self.current_url,
                            timeout=settings.PLAYWRIGHT_TIMEOUT,
                            wait_until="domcontentloaded"
                        )
                        await self.page.wait_for_timeout(1000)
                        logger.info(f"Successfully re-navigated to {self.current_url}")
                    except Exception as nav_error:
                        logger.error(f"Failed to re-navigate to {self.current_url}: {nav_error}")
                        return BrowserResult.error_result(
                            command_id,
                            f"Page was closed and re-navigation failed: {str(nav_error)}",
                            "PageClosed"
                        )
            except Exception as reinit_error:
                return BrowserResult.error_result(
                    command_id,
                    f"Page was closed and reinitialization failed: {str(reinit_error)}",
                    "PageClosed"
                )
        
        field_mappings = params.get("field_mappings", {})
        filled_count = 0
        errors = []
        
        logger.info(f"Worker {self.worker_id} attempting to fill {len(field_mappings)} fields")
        
        for selector, value in field_mappings.items():
            if not value:
                continue
            
            try:
                element = self.page.locator(selector).first
                element_count = await element.count()
                if element_count == 0:
                    errors.append(f"Element not found: {selector}")
                    logger.debug(f"Worker {self.worker_id}: Element not found for selector: {selector}")
                    continue
                
                logger.debug(f"Worker {self.worker_id}: Found element for {selector}, attempting to fill with value: {value[:50] if value else 'empty'}")
                
                tag_name = await element.evaluate("el => el.tagName.toLowerCase()")
                input_type = await element.get_attribute("type") or ""
                
                logger.debug(f"Worker {self.worker_id}: Element {selector} is {tag_name}, type={input_type}")
                
                if input_type != "hidden":
                    await element.scroll_into_view_if_needed()
                    await element.wait_for(state="visible", timeout=5000)
                
                if tag_name == "input" and input_type == "file":
                    # Handle file upload
                    file_path = value
                    if value.startswith(("http://", "https://")):
                        if not AIOHTTP_AVAILABLE:
                            errors.append("Logo URL download requires aiohttp package")
                            continue
                        
                        import tempfile
                        async with aiohttp.ClientSession() as session:
                            async with session.get(value) as response:
                                if response.status == 200:
                                    file_ext = os.path.splitext(value)[1] or ".png"
                                    with tempfile.NamedTemporaryFile(delete=False, suffix=file_ext) as tmp_file:
                                        tmp_file.write(await response.read())
                                        file_path = tmp_file.name
                                else:
                                    raise Exception(f"Failed to download file: HTTP {response.status}")
                    
                    if os.path.exists(file_path):
                        valid_extensions = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp", ".bmp"]
                        file_ext = os.path.splitext(file_path)[1].lower()
                        if file_ext in valid_extensions:
                            await element.set_input_files(file_path)
                            filled_count += 1
                            # Clean up temp file if downloaded
                            if value.startswith(("http://", "https://")) and os.path.exists(file_path):
                                try:
                                    os.unlink(file_path)
                                except:
                                    pass
                        else:
                            errors.append(f"Invalid file type: {file_ext}")
                    else:
                        errors.append(f"File not found: {file_path}")
                
                elif tag_name == "textarea":
                    await element.clear()
                    await element.fill(value)
                    # Verify value was set
                    try:
                        actual_value = await element.input_value()
                        if actual_value != value:
                            logger.warning(f"Worker {self.worker_id}: Textarea value didn't stick for {selector}, retrying...")
                            await element.clear()
                            await element.fill(value)
                            await self.page.wait_for_timeout(300)
                        filled_count += 1
                    except:
                        filled_count += 1  # Assume it worked if we can't verify
                
                elif tag_name == "select":
                    try:
                        # Try to select by value first
                        await element.select_option(value, timeout=10000)
                        filled_count += 1
                        logger.debug(f"Worker {self.worker_id}: Selected option by value: {value}")
                    except Exception as value_error:
                        try:
                            # Try to select by label
                            await element.select_option(label=value, timeout=10000)
                            filled_count += 1
                            logger.debug(f"Worker {self.worker_id}: Selected option by label: {value}")
                        except Exception as label_error:
                            # Try to find a partial match in options
                            try:
                                options = await element.evaluate("""
                                    (el) => {
                                        return Array.from(el.options).map(opt => ({
                                            value: opt.value,
                                            text: opt.text.trim()
                                        }));
                                    }
                                """)
                                
                                # Try to find a match (case-insensitive, partial)
                                value_lower = value.lower()
                                matched = False
                                for opt in options:
                                    if (opt['value'].lower() == value_lower or 
                                        opt['text'].lower() == value_lower or
                                        value_lower in opt['text'].lower() or
                                        opt['text'].lower() in value_lower):
                                        await element.select_option(opt['value'], timeout=10000)
                                        filled_count += 1
                                        logger.info(f"Worker {self.worker_id}: Matched '{value}' to option '{opt['text']}' (value: {opt['value']})")
                                        matched = True
                                        break
                                
                                if not matched:
                                    errors.append(f"Could not find matching option for select {selector} with value '{value}'. Available options: {[opt['text'] for opt in options[:5]]}")
                                    logger.warning(f"Worker {self.worker_id}: No match for select {selector} value '{value}'")
                            except Exception as match_error:
                                errors.append(f"Error selecting option '{value}' in {selector}: {str(match_error)}")
                                logger.warning(f"Worker {self.worker_id}: Failed to select option: {str(match_error)}")
                
                elif tag_name == "input":
                    # Clear and fill, then verify the value was set
                    await element.clear()
                    await element.fill(value)
                    # Verify the value was actually set (important for required fields)
                    try:
                        actual_value = await element.input_value()
                        if actual_value != value:
                            # Value didn't stick, try again
                            logger.warning(f"Worker {self.worker_id}: Value didn't stick for {selector}, retrying...")
                            await element.clear()
                            await element.fill(value)
                            await self.page.wait_for_timeout(300)
                            actual_value = await element.input_value()
                            if actual_value != value:
                                errors.append(f"Value not set correctly for {selector}: expected '{value}', got '{actual_value}'")
                                continue
                        filled_count += 1
                        logger.debug(f"Worker {self.worker_id}: Verified value set for {selector}: '{actual_value}'")
                    except Exception as verify_error:
                        # If we can't verify, assume it worked
                        filled_count += 1
                        logger.debug(f"Worker {self.worker_id}: Could not verify value for {selector}: {verify_error}")
                
                else:
                    await element.fill(value)
                    filled_count += 1
                
                await self.page.wait_for_timeout(200)
            
            except PlaywrightTimeoutError as e:
                error_msg = f"Element not found or not visible: {selector}"
                errors.append(error_msg)
                logger.warning(f"Worker {self.worker_id}: Timeout filling {selector}: {str(e)}")
            except Exception as e:
                error_msg = f"Error filling {selector}: {str(e)}"
                errors.append(error_msg)
                logger.warning(f"Worker {self.worker_id}: Exception filling {selector}: {str(e)}")
        
        logger.info(
            f"Worker {self.worker_id} fill_form complete: "
            f"filled {filled_count}/{len(field_mappings)} fields, "
            f"{len(errors)} errors"
        )
        if errors:
            logger.warning(f"Worker {self.worker_id} fill_form errors: {errors[:5]}")  # Log first 5 errors
        
        return BrowserResult.success(command_id, {
            "filled_count": filled_count,
            "total_fields": len(field_mappings),
            "errors": errors
        })
    
    async def _handle_submit_form(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle submit_form command"""
        # Initialize browser if needed
        if not self.page:
            try:
                await self.initialize_browser()
                # If we have a stored URL, navigate to it
                if self.current_url:
                    logger.info(f"Worker {self.worker_id}: Navigating to stored URL before submit: {self.current_url}")
                    await self.page.goto(self.current_url, timeout=settings.PLAYWRIGHT_TIMEOUT, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(2000)
            except Exception as e:
                return BrowserResult.error_result(
                    command_id, 
                    f"Browser not initialized and initialization failed: {str(e)}", 
                    "BrowserNotInitialized"
                )
        
        # Verify page is still on the form
        try:
            current_url = self.page.url
            if self.current_url and current_url != self.current_url and "about:blank" not in current_url:
                # Page navigated away, re-navigate to form
                logger.warning(f"Worker {self.worker_id}: Page navigated away ({current_url}), re-navigating to form")
                await self.page.goto(self.current_url, timeout=settings.PLAYWRIGHT_TIMEOUT, wait_until="domcontentloaded")
                await self.page.wait_for_timeout(2000)
        except Exception as e:
            logger.warning(f"Worker {self.worker_id}: Could not verify page URL: {e}")
        
        # Wait a bit for any animations or dynamic content
        await self.page.wait_for_timeout(1000)
        
        submit_button_selector = params.get("submit_button_selector")
        submitted = False
        submit_error = None
        
        # Try provided selector first
        if submit_button_selector:
            try:
                logger.info(f"Worker {self.worker_id}: Attempting to submit using provided selector: {submit_button_selector}")
                submit_button = self.page.locator(submit_button_selector).first
                count = await submit_button.count()
                if count > 0:
                    await submit_button.scroll_into_view_if_needed()
                    await submit_button.wait_for(state="visible", timeout=10000)
                    await submit_button.wait_for(state="attached", timeout=5000)
                    await submit_button.click(timeout=10000)
                    submitted = True
                    logger.info(f"Worker {self.worker_id}: Successfully clicked submit button using selector: {submit_button_selector}")
                else:
                    logger.warning(f"Worker {self.worker_id}: Submit button not found with selector: {submit_button_selector}")
            except Exception as e:
                submit_error = str(e)
                logger.warning(f"Worker {self.worker_id}: Failed to click submit with provided selector: {submit_error}")
                submit_button_selector = None
        
        # Try common submit button selectors
        if not submitted:
            submit_selectors = [
                "button[type='submit']",
                "input[type='submit']",
                "button:has-text('Submit')",
                "button:has-text('Submit Product')",
                "form button[type='submit']",
                "#submissionForm button[type='submit']",
                "button:has-text('Add')",
                "button:has-text('Save')",
            ]
            
            logger.info(f"Worker {self.worker_id}: Trying common submit button selectors...")
            for selector in submit_selectors:
                try:
                    button = self.page.locator(selector).first
                    count = await button.count()
                    if count > 0:
                        logger.info(f"Worker {self.worker_id}: Found submit button with selector: {selector}")
                        await button.scroll_into_view_if_needed()
                        await button.wait_for(state="visible", timeout=10000)
                        await button.wait_for(state="attached", timeout=5000)
                        
                        # Wait a bit for any animations
                        await self.page.wait_for_timeout(500)
                        
                        # Try multiple click methods
                        try:
                            # Method 1: Normal click
                            await button.click(timeout=10000)
                            logger.info(f"Worker {self.worker_id}: Clicked button using normal click")
                        except Exception as click_error:
                            try:
                                # Method 2: Force click
                                await button.click(force=True, timeout=10000)
                                logger.info(f"Worker {self.worker_id}: Clicked button using force click")
                            except Exception as force_error:
                                # Method 3: JavaScript click to ensure event handlers are called
                                await self.page.evaluate("""
                                    (selector) => {
                                        const button = document.querySelector(selector);
                                        if (button) {
                                            // Create and dispatch click event
                                            const clickEvent = new MouseEvent('click', {
                                                bubbles: true,
                                                cancelable: true,
                                                view: window,
                                                buttons: 1
                                            });
                                            button.dispatchEvent(clickEvent);
                                            return true;
                                        }
                                        return false;
                                    }
                                """, selector)
                                logger.info(f"Worker {self.worker_id}: Clicked button using JavaScript event")
                        
                        submitted = True
                        logger.info(f"Worker {self.worker_id}: Successfully triggered submit button: {selector}")
                        
                        # Wait for form submission to process (form might have async submission)
                        await self.page.wait_for_timeout(2000)
                        
                        # Verify form was submitted by checking if success/error message appeared
                        # Wait a bit more for async operations
                        await self.page.wait_for_timeout(2000)
                        try:
                            # Check if form is still present (if gone, likely submitted)
                            form_count = await self.page.locator("form").count()
                            
                            success_msg = await self.page.locator("#successMessage").count()
                            error_msg = await self.page.locator("#errorMessage").count()
                            
                            if success_msg > 0:
                                success_visible = await self.page.locator("#successMessage").first.is_visible()
                                if success_visible:
                                    logger.info(f"Worker {self.worker_id}: Success message appeared and is visible after submit")
                            elif error_msg > 0:
                                error_visible = await self.page.locator("#errorMessage").first.is_visible()
                                if error_visible:
                                    error_text = await self.page.locator("#errorMessage").inner_text()
                                    logger.warning(f"Worker {self.worker_id}: Error message appeared: {error_text[:200]}")
                                    # Check if it's a validation error (form still present)
                                    if form_count > 0:
                                        # Form still there - might be validation error
                                        # Check required fields
                                        required_fields = await self.page.locator("input[required], textarea[required]").count()
                                        logger.warning(f"Worker {self.worker_id}: Form still present with {required_fields} required fields - validation may have failed")
                        except Exception as e:
                            logger.debug(f"Worker {self.worker_id}: Could not verify submission status: {e}")
                        
                        break
                except Exception as e:
                    logger.debug(f"Worker {self.worker_id}: Selector {selector} failed: {str(e)}")
                    continue
        
        # Last resort: submit form via JavaScript
        # Try to trigger the submit button click event instead of form.submit()
        # This ensures event handlers are called
        if not submitted:
            try:
                logger.info(f"Worker {self.worker_id}: Attempting form submission via JavaScript (triggering button click)")
                form_submitted = await self.page.evaluate("""
                    () => {
                        // Try to find and click the submit button via JavaScript
                        const submitButton = document.querySelector('button[type="submit"]') || 
                                           document.querySelector('input[type="submit"]') ||
                                           document.querySelector('form button');
                        if (submitButton) {
                            // Create and dispatch click event to trigger all handlers
                            const clickEvent = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: window
                            });
                            submitButton.dispatchEvent(clickEvent);
                            return true;
                        }
                        
                        // Fallback to form.submit() if no button found
                        const form = document.querySelector('form');
                        if (form) {
                            // Try to trigger submit event first
                            const submitEvent = new Event('submit', {
                                bubbles: true,
                                cancelable: true
                            });
                            if (form.dispatchEvent(submitEvent)) {
                                form.submit();
                            }
                            return true;
                        }
                        return false;
                    }
                """)
                if form_submitted:
                    submitted = True
                    logger.info(f"Worker {self.worker_id}: Form submitted via JavaScript (button click event)")
                else:
                    logger.warning(f"Worker {self.worker_id}: No form or button found for JavaScript submission")
            except Exception as e:
                submit_error = str(e)
                logger.error(f"Worker {self.worker_id}: JavaScript form submission failed: {submit_error}")
        
        # Wait for submission to process and verify
        await self.page.wait_for_timeout(3000)
        
        # Double-check if form was actually submitted
        if submitted:
            try:
                # Check for success or error messages
                success_count = await self.page.locator("#successMessage, .success-message").count()
                error_count = await self.page.locator("#errorMessage, .error-message").count()
                
                # Check if messages are visible
                success_visible = False
                error_visible = False
                error_text = ""
                
                if success_count > 0:
                    success_visible = await self.page.locator("#successMessage, .success-message").first.is_visible()
                    if success_visible:
                        logger.info(f"Worker {self.worker_id}: Success message is visible after submit")
                
                if error_count > 0:
                    error_element = self.page.locator("#errorMessage, .error-message").first
                    error_visible = await error_element.is_visible()
                    if error_visible:
                        error_text = await error_element.inner_text()
                        logger.warning(f"Worker {self.worker_id}: Error message is visible after submit: {error_text[:200]}")
                        
                        # If error is visible, check if it's a validation error
                        # Check if form is still present (validation errors keep form visible)
                        form_count = await self.page.locator("form").count()
                        if form_count > 0:
                            # Form still there - check required fields
                            try:
                                # Check if required fields are filled
                                required_inputs = await self.page.locator("input[required], textarea[required]").all()
                                unfilled_required = []
                                for req_input in required_inputs:
                                    value = await req_input.input_value()
                                    if not value or value.strip() == "":
                                        name = await req_input.get_attribute("name") or await req_input.get_attribute("id") or "unknown"
                                        unfilled_required.append(name)
                                
                                if unfilled_required:
                                    logger.error(f"Worker {self.worker_id}: Required fields not filled: {unfilled_required}")
                                    return BrowserResult.error_result(
                                        command_id,
                                        f"Form validation failed: Required fields not filled: {', '.join(unfilled_required)}",
                                        "ValidationError"
                                    )
                            except Exception as check_error:
                                logger.debug(f"Worker {self.worker_id}: Could not check required fields: {check_error}")
                        
                        # Return error if error message is visible
                        return BrowserResult.error_result(
                            command_id,
                            f"Form submission failed: {error_text[:200]}",
                            "SubmissionError"
                        )
                
                # If success is visible, return success
                if success_visible:
                    return BrowserResult.success(command_id, {"submitted": True})
                
            except Exception as e:
                logger.debug(f"Worker {self.worker_id}: Could not verify submission status: {e}")
        
        if not submitted:
            error_msg = f"Failed to submit form. Last error: {submit_error or 'No submit button found'}"
            logger.error(f"Worker {self.worker_id}: {error_msg}")
            return BrowserResult.error_result(command_id, error_msg, "SubmitFailed")
        
        logger.info(f"Worker {self.worker_id}: Form submission completed successfully")
        return BrowserResult.success(command_id, {"submitted": submitted})
    
    async def _handle_detect_captcha(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle detect_captcha command"""
        # Check if page exists and is still open
        if not self.page:
            try:
                await self.initialize_browser()
            except Exception as e:
                return BrowserResult.error_result(
                    command_id, 
                    f"Browser not initialized: {str(e)}", 
                    "BrowserNotInitialized"
                )
        
        # Verify page is still open
        try:
            await self.page.url
        except Exception as e:
            # Page was closed, try to reinitialize and re-navigate
            logger.warning(f"Page was closed during detect_captcha, reinitializing for worker {self.worker_id}")
            try:
                await self.initialize_browser()
                if self.current_url:
                    await self.page.goto(self.current_url, timeout=settings.PLAYWRIGHT_TIMEOUT, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(1000)
            except Exception as reinit_error:
                return BrowserResult.error_result(
                    command_id,
                    f"Page was closed and reinitialization failed: {str(reinit_error)}",
                    "PageClosed"
                )
        
        captcha_selectors = [
            "iframe[src*='recaptcha']",
            "iframe[src*='hcaptcha']",
            ".g-recaptcha",
            "#captcha",
            "[data-sitekey]",
        ]
        
        for selector in captcha_selectors:
            try:
                element = self.page.locator(selector).first
                if await element.count() > 0:
                    return BrowserResult.success(command_id, {"has_captcha": True})
            except Exception:
                continue
        
        page_text = (await self.page.inner_text("body")).lower()
        has_captcha = "captcha" in page_text or "verify you are human" in page_text
        
        return BrowserResult.success(command_id, {"has_captcha": has_captcha})
    
    async def _handle_get_page_content(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle get_page_content command"""
        # Check if page exists and is still open
        if not self.page:
            try:
                await self.initialize_browser()
            except Exception as e:
                return BrowserResult.error_result(
                    command_id, 
                    f"Browser not initialized: {str(e)}", 
                    "BrowserNotInitialized"
                )
        
        # Verify page is still open
        try:
            content = await self.page.content()
            return BrowserResult.success(command_id, {"content": content})
        except Exception as e:
            # Page was closed, try to reinitialize and re-navigate
            logger.warning(f"Page was closed during get_page_content, reinitializing for worker {self.worker_id}")
            try:
                await self.initialize_browser()
                if self.current_url:
                    await self.page.goto(self.current_url, timeout=settings.PLAYWRIGHT_TIMEOUT, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(1000)
                    content = await self.page.content()
                    return BrowserResult.success(command_id, {"content": content})
            except Exception as reinit_error:
                return BrowserResult.error_result(
                    command_id,
                    f"Page was closed and reinitialization failed: {str(reinit_error)}",
                    "PageClosed"
                )
            return BrowserResult.error_result(
                command_id,
                f"Failed to get page content: {str(e)}",
                "PageClosed"
            )
    
    async def _handle_extract_form_fields_dom(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle extract_form_fields_dom command"""
        # Check if page exists and is still open
        if not self.page:
            try:
                await self.initialize_browser()
            except Exception as e:
                return BrowserResult.error_result(
                    command_id, 
                    f"Browser not initialized: {str(e)}", 
                    "BrowserNotInitialized"
                )
        
        # Verify page is still open
        try:
            await self.page.url
        except Exception as e:
            # Page was closed, try to reinitialize and re-navigate
            logger.warning(f"Page was closed during extract_form_fields_dom, reinitializing for worker {self.worker_id}")
            try:
                await self.initialize_browser()
                if self.current_url:
                    await self.page.goto(self.current_url, timeout=settings.PLAYWRIGHT_TIMEOUT, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(1000)
            except Exception as reinit_error:
                return BrowserResult.error_result(
                    command_id,
                    f"Page was closed and reinitialization failed: {str(reinit_error)}",
                    "PageClosed"
                )
        
        try:
            await self.page.wait_for_load_state("domcontentloaded", timeout=5000)
        except PlaywrightTimeoutError:
            pass
        
        await self.page.wait_for_timeout(1000)
        
        form_data = await self.page.evaluate("""
            () => {
                const fields = [];
                const forms = document.querySelectorAll('form');
                let mainForm = forms[0] || document.body;
                
                const formElements = mainForm.querySelectorAll('input, textarea, select');
                
                formElements.forEach((el, index) => {
                    const isHidden = el.type === 'hidden';
                    if (isHidden) return;
                    
                    const tagName = el.tagName.toLowerCase();
                    const type = el.type || '';
                    const name = el.name || el.id || '';
                    const id = el.id || '';
                    const placeholder = el.placeholder || '';
                    const label = el.labels && el.labels[0] ? el.labels[0].textContent.trim() : '';
                    
                    let labelText = label;
                    if (!labelText && id) {
                        const labelEl = document.querySelector(`label[for="${id}"]`);
                        if (labelEl) labelText = labelEl.textContent.trim();
                    }
                    if (!labelText && name) {
                        const labelEl = document.querySelector(`label[for="${name}"]`);
                        if (labelEl) labelText = labelEl.textContent.trim();
                    }
                    
                    let selector = '';
                    if (id) {
                        selector = `#${id}`;
                    } else if (name) {
                        selector = `[name="${name}"]`;
                    } else {
                        selector = `${tagName}[type="${type}"]:nth-of-type(${index + 1})`;
                    }
                    
                    const required = el.hasAttribute('required') || 
                                   el.getAttribute('aria-required') === 'true';
                    
                    const fieldText = (name + ' ' + id + ' ' + labelText + ' ' + placeholder).toLowerCase();
                    let purpose = 'other';
                    if (fieldText.match(/name|title|product|company|business/)) {
                        purpose = 'name';
                    } else if (fieldText.match(/url|website|site|link|homepage|domain/)) {
                        purpose = 'url';
                    } else if (fieldText.match(/email|mail|contact.*email/)) {
                        purpose = 'email';
                    } else if (fieldText.match(/description|desc|about|details|info|summary/)) {
                        purpose = 'description';
                    } else if (fieldText.match(/category|tag|tags|type|industry/)) {
                        purpose = 'category';
                    } else if (fieldText.match(/logo|image|picture|photo|icon/)) {
                        purpose = 'logo';
                    }
                    
                    let options = [];
                    if (tagName === 'select') {
                        options = Array.from(el.options).map(opt => opt.text || opt.value);
                    }
                    
                    fields.push({
                        selector: selector,
                        type: type || tagName,
                        name: name || id || '',
                        label: labelText,
                        placeholder: placeholder,
                        required: required,
                        purpose: purpose,
                        options: options.length > 0 ? options : undefined
                    });
                });
                
                let submitButton = null;
                const submitSelectors = [
                    'button[type="submit"]',
                    'input[type="submit"]',
                ];
                
                for (const sel of submitSelectors) {
                    const btn = mainForm.querySelector(sel);
                    if (btn) {
                        const btnId = btn.id || '';
                        const btnName = btn.name || '';
                        submitButton = {
                            selector: btnId ? `#${btnId}` : (btnName ? `[name="${btnName}"]` : sel),
                            text: btn.textContent?.trim() || btn.value || ''
                        };
                        break;
                    }
                }
                
                if (!submitButton) {
                    const anyButton = mainForm.querySelector('button, input[type="button"]');
                    if (anyButton) {
                        const btnId = anyButton.id || '';
                        submitButton = {
                            selector: btnId ? `#${btnId}` : 'button:first-of-type',
                            text: anyButton.textContent?.trim() || anyButton.value || ''
                        };
                    }
                }
                
                const formSelector = forms[0] ? 
                    (forms[0].id ? `#${forms[0].id}` : (forms[0].name ? `form[name="${forms[0].name}"]` : 'form')) :
                    'body';
                
                return {
                    fields: fields,
                    submit_button: submitButton,
                    form_selector: formSelector
                };
            }
        """)
        
        return BrowserResult.success(command_id, form_data)
    
    async def _handle_take_screenshot(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle take_screenshot command"""
        if not self.page:
            return BrowserResult.error_result(command_id, "Browser not initialized", "BrowserNotInitialized")
        
        path = params.get("path")
        os.makedirs(os.path.dirname(path) if os.path.dirname(path) else ".", exist_ok=True)
        await self.page.screenshot(path=path, full_page=True)
        
        return BrowserResult.success(command_id, {"path": path})
    
    async def _handle_detect_submission_page(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle detect_submission_page command"""
        # Initialize browser if needed
        if not self.page:
            try:
                await self.initialize_browser()
                # If we have a stored URL, navigate to it
                if self.current_url:
                    logger.info(f"Worker {self.worker_id}: Navigating to stored URL: {self.current_url}")
                    await self.page.goto(self.current_url, timeout=settings.PLAYWRIGHT_TIMEOUT, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(1000)
            except Exception as e:
                return BrowserResult.error_result(
                    command_id, 
                    f"Browser not initialized and initialization failed: {str(e)}", 
                    "BrowserNotInitialized"
                )
        
        try:
            await self.page.wait_for_load_state("domcontentloaded", timeout=3000)
        except PlaywrightTimeoutError:
            pass
        
        await self.page.wait_for_timeout(500)
        
        submission_keywords = [
            "submit", "add listing", "add your", "submit your",
            "add product", "submit product", "new listing", "list your",
        ]
        
        page_text = await self.page.inner_text("body")
        page_text_lower = page_text.lower()
        
        form_count = await self.page.locator("form").count()
        input_count = await self.page.locator("input, textarea, select").count()
        submit_buttons = await self.page.locator("button[type='submit'], input[type='submit']").count()
        has_keywords = any(keyword in page_text_lower for keyword in submission_keywords)
        
        detected = (form_count > 0 and input_count >= 2) or submit_buttons > 0 or has_keywords
        
        return BrowserResult.success(command_id, {"detected": detected})
    
    async def _handle_wait_for_confirmation(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle wait_for_confirmation command"""
        if not self.page:
            return BrowserResult.error_result(command_id, "Browser not initialized", "BrowserNotInitialized")
        
        timeout_ms = params.get("timeout", 10000)
        # Wait longer for success message to appear (test forms often show it after a delay)
        await self.page.wait_for_timeout(min(3000, timeout_ms))
        
        # Wait for page to potentially navigate or update after submission
        try:
            await self.page.wait_for_load_state("domcontentloaded", timeout=5000)
        except:
            pass
        
        # Wait a bit more for dynamic content (success messages, etc.)
        await self.page.wait_for_timeout(1000)
        
        success_keywords = [
            "thank you", "success", "submitted", "received", "confirmation",
            "form submitted", "submission successful", "thank you for", 
            "your submission", "successfully submitted", "form received"
        ]
        error_keywords = ["error", "failed", "invalid", "required", "captcha", "verification failed"]
        
        page_text = (await self.page.inner_text("body")).lower()
        current_url = self.page.url
        
        # Check for success message elements (common in test forms)
        try:
            # Check multiple selectors for success messages
            success_selectors = [
                "#successMessage",
                ".success",
                "[class*='success']",
                "#submission-success",
                ".submission-success",
                "[id*='success']",
                "[class*='alert-success']"
            ]
            
            for selector in success_selectors:
                try:
                    element = self.page.locator(selector).first
                    count = await element.count()
                    if count > 0:
                        # Check if element is visible
                        is_visible = await element.is_visible()
                        if is_visible:
                            success_text = await element.inner_text()
                            logger.info(f"Worker {self.worker_id}: Success message element detected: {selector} - '{success_text[:100]}'")
                            return BrowserResult.success(command_id, {
                                "status": "success",
                                "message": f"Submission successful (success message detected: {success_text[:200]})",
                                "url": current_url
                            })
                except Exception:
                    continue
        except Exception as e:
            logger.debug(f"Worker {self.worker_id}: Error checking for success elements: {e}")
        
        # Check for error message elements
        try:
            error_elements = await self.page.locator(
                "#errorMessage, .error, [class*='error'], .alert-danger, .alert-error"
            ).count()
            if error_elements > 0:
                error_text = await self.page.locator("#errorMessage, .error, [class*='error']").first.inner_text()
                logger.warning(f"Worker {self.worker_id}: Error message element detected: {error_text[:100]}")
                return BrowserResult.success(command_id, {
                    "status": "error",
                    "message": f"Submission failed (error message detected): {error_text[:200]}",
                    "url": current_url
                })
        except:
            pass
        
        status = "pending"
        message = "Submission status unclear"
        
        # Check for success keywords
        for keyword in success_keywords:
            if keyword in page_text:
                status = "success"
                message = f"Submission successful (detected: {keyword})"
                logger.info(f"Worker {self.worker_id}: {message}")
                break
        
        # Check for error keywords (only if no success found)
        if status == "pending":
            for keyword in error_keywords:
                if keyword in page_text:
                    status = "error"
                    message = f"Submission may have failed (detected: {keyword})"
                    logger.warning(f"Worker {self.worker_id}: {message}")
                    break
        
        # If still pending, check if URL changed (indicates navigation after submission)
        if status == "pending":
            if self.current_url and current_url != self.current_url:
                # URL changed after submission - likely success
                status = "success"
                message = f"Submission likely successful (URL changed from {self.current_url} to {current_url})"
                logger.info(f"Worker {self.worker_id}: {message}")
            elif "form" not in page_text.lower() or len(page_text) < 100:
                # Form is gone and page is different - likely success
                status = "success"
                message = "Submission likely successful (form no longer present on page)"
                logger.info(f"Worker {self.worker_id}: {message}")
            else:
                # Still unclear, but if we got here, form was submitted
                # Default to success if form submission returned True
                status = "success"
                message = "Submission completed (status unclear but form was submitted)"
                logger.info(f"Worker {self.worker_id}: {message}")
        
        return BrowserResult.success(command_id, {
            "status": status,
            "message": message,
            "url": current_url
        })
    
    async def _handle_close(self, command_id: str, params: Dict) -> BrowserResult:
        """Handle close command - only closes page, keeps browser alive"""
        await self.cleanup_browser(full_cleanup=False)
        return BrowserResult.success(command_id, {})
    
    async def run(self):
        """
        Main worker loop that processes commands.
        Runs until shutdown command is received.
        
        Browser is initialized lazily on first command, not on startup,
        to avoid issues with pages closing before first use.
        """
        self.is_running = True
        logger.info(f"Browser worker {self.worker_id} started and ready (browser will be initialized on first command)")
        
        while self.is_running:
            try:
                # Get command from queue (blocking with timeout)
                try:
                    command_dict = self.command_queue.get(timeout=1.0)
                except:
                    continue
                
                if command_dict is None:  # Shutdown signal
                    logger.info(f"Browser worker {self.worker_id} received shutdown signal")
                    break
                
                command = BrowserCommand.from_dict(command_dict)
                
                # Handle command
                result = await self.handle_command(command)
                
                # Send result back
                self.result_queue.put(result.to_dict())
            
            except Exception as e:
                logger.error(f"Browser worker {self.worker_id} error in main loop: {e}")
                traceback.print_exc()
        
        # Cleanup - full cleanup on shutdown
        await self.cleanup_browser(full_cleanup=True)
        logger.info(f"Browser worker {self.worker_id} stopped")


def worker_main(command_queue: Queue, result_queue: Queue, worker_id: int):
    """
    Main entry point for worker process.
    
    This function runs in a separate process and creates an event loop
    to run the browser worker asynchronously.
    
    Args:
        command_queue: Queue to receive commands
        result_queue: Queue to send results
        worker_id: Unique worker identifier
    """
    # Re-initialize logger in worker process (multiprocessing requires this on Windows)
    import logging
    import sys
    logging.basicConfig(
        level=logging.DEBUG if settings.DEBUG else logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[logging.StreamHandler(sys.stdout)]
    )
    worker_logger = logging.getLogger("genie_ops")
    
    worker = BrowserWorker(command_queue, result_queue, worker_id)
    
    # Create and run event loop
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    try:
        loop.run_until_complete(worker.run())
    except KeyboardInterrupt:
        worker_logger.info(f"Browser worker {worker_id} interrupted")
    except Exception as e:
        worker_logger.error(f"Browser worker {worker_id} crashed: {e}")
        traceback.print_exc()
    finally:
        loop.close()
